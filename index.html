<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="less is More">
<meta property="og:type" content="website">
<meta property="og:title" content="Shan's Blog">
<meta property="og:url" content="https://xl2013.github.io/index.html">
<meta property="og:site_name" content="Shan's Blog">
<meta property="og:description" content="less is More">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shan's Blog">
<meta name="twitter:description" content="less is More">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xl2013.github.io/"/>





  <title> Shan's Blog </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shan's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xl2013.github.io/2017/04/09/LinearRegression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/naruto.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/09/LinearRegression/" itemprop="url">
                  LinearRegression
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-09T16:42:01+08:00">
                2017-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Machine-Learning-algorithms/" itemprop="url" rel="index">
                    <span itemprop="name">Machine Learning algorithms</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h2><h3 id="基础数学知识"><a href="#基础数学知识" class="headerlink" title="基础数学知识"></a>基础数学知识</h3><ol>
<li><p>最小二乘法（least square）</p>
<p> 最小二乘法是一种数学优化技术。它通过最小化误差的平方和寻找数据的最佳函数匹配。<br> 利用最小二乘法可以简便地求得未知的数据，并使得这些求得的数据与实际数据之间误差的平方和为最小.</p>
</li>
</ol>
<script type="math/tex; mode=display">min \sum_{i=1}^m (y_\theta(x)-y)^2</script><ol>
<li><p>likehood 似然（最大似然评估 ）</p>
<p> likehood function：<br> $L(\theta \mid x) = f(x \mid \theta)$</p>
<p> 在上式中，如果x已经给出，预测 $\theta$ 的值，则该函数为似然函数。如果 $\theta$ 已经给出，预测x的值，那么这就是普通的概率函数。</p>
<p> 而最大似然估计就是取一定的 $\theta$值，使得似然函数最大，即：</p>
<script type="math/tex; mode=display">arg  \;max \;L(\theta \mid X)</script></li>
</ol>
<ol>
<li><p>矩阵的迹及其部分等式</p>
<p> 定义：矩阵的迹 $tr(A) = \sum<em>{i=1}^m a</em>{ii}$ 为标量且A为标量或方阵<br> 一些公式：</p>
<script type="math/tex; mode=display">tr(ABC) = tr(CAB) = tr(BCA)</script><script type="math/tex; mode=display">tr(A+B) = tr(A) + tr(B)</script><script type="math/tex; mode=display">\Delta_A tr(AB) = B^T</script><script type="math/tex; mode=display">\Delta_{A^T}f(A) = (\Delta_Af(A))^T</script><script type="math/tex; mode=display">\Delta_Atr(ABA^TC) = CAB+C^TAB^T</script><script type="math/tex; mode=display">\Delta_A|A| = |A|(A^{-1})^T</script><p> 等式的证明见参考资料链接</p>
</li>
<li><p>矩阵求导公式<br> 矩阵A对矩阵B求导，就是矩阵A中的每个值对矩阵B中的每个值求导，向量同理。</p>
<p> 一些重要的公式：</p>
<script type="math/tex; mode=display">\frac{d X}{d X^T } = I</script><script type="math/tex; mode=display">\frac{d X^T}{d X } = I</script><script type="math/tex; mode=display">\frac{d AX}{d X^T } = A</script><script type="math/tex; mode=display">\frac{d AX^T}{d X } = A</script><script type="math/tex; mode=display">\frac{d U^TV}{d X } = \frac{d U^T}{d X}V + \frac{d V^T}{d X }U</script><p> 等式的证明见参考资料链接</p>
</li>
</ol>
<h3 id="基础机器学习知识"><a href="#基础机器学习知识" class="headerlink" title="基础机器学习知识"></a>基础机器学习知识</h3><ol>
<li>学习过程</li>
<li>hypothesis</li>
<li>classification、regression</li>
<li>loss function(error function)</li>
</ol>
<h2 id="LinearRegression"><a href="#LinearRegression" class="headerlink" title="LinearRegression"></a>LinearRegression</h2><h3 id="理论模型"><a href="#理论模型" class="headerlink" title="理论模型"></a>理论模型</h3><blockquote>
<p>在统计学中，线性回归是利用称为线性回归方程的最小二乘函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。</p>
</blockquote>
<p>在线性回归中，数据使用线性预测函数来建模，并且未知的模型参数也是通过数据来估计。这些模型被叫做线性模型。在机器学习算法中，我们使用如下的线性函数来预测y：</p>
<script type="math/tex; mode=display">h_\theta(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 ...</script><p>即：</p>
<script type="math/tex; mode=display">h_\theta(X) = \theta^T x</script><p>其中：</p>
<script type="math/tex; mode=display">\theta = \begin{bmatrix} \theta_0\\ \theta_1\\... \end{bmatrix}
   x =  \begin{bmatrix} x_0\\ x_1\\... \end{bmatrix}</script><p>也可写成：</p>
<script type="math/tex; mode=display">y = Wx + b</script><p>上面式子中,$\theta$ 和W都是一个意思，称为参数或者权重(weight)。其中 $\theta<em>0$ 和b表示偏差（bias），也可称为误差项。之后我们统一使用 $ h</em>\theta(X) = \theta^T x$</p>
<p>为了评估线性模型的性能，线性回归使用最小二乘法来作为损失函数（loss function | cost function）：</p>
<script type="math/tex; mode=display">J(\theta) = 1/2m\sum_{i=1}^m (h(x^i)-y^i)^2</script><p>至于为什么如此选择，后面再进行解释。</p>
<h3 id="minimize-J-θ"><a href="#minimize-J-θ" class="headerlink" title="minimize J(θ)"></a>minimize J(θ)</h3><p>为了提升预测准确度或者时候模型性能，我们需要选择 $\theta$ 来最小化损失函数即：</p>
<script type="math/tex; mode=display">\theta = arg \; min \; J(\theta)</script><p>一般有两种方法求解：</p>
<h4 id="gradient-descent"><a href="#gradient-descent" class="headerlink" title="gradient descent"></a>gradient descent</h4><p>为了选择 $\theta$ 最小化  $J(\theta)$,先给 $\theta$一个初始值，然后重复的改变它,直到收敛得到一个 $\theta$,使得 $J(\theta)$ 最小。</p>
<p>gradient descent就是这样一个算法，从一个初始 $\theta$开始，然后重复的执行如下更新：</p>
<script type="math/tex; mode=display">\theta_j = \theta_j - \alpha \frac{\delta}{\delta\theta_j}J(\theta)</script><p>表达式中 $\alpha$代表学习速率，表示 $\theta$值收敛步长。$\frac{\delta}{\delta\theta_j}J(\theta_j)$ 代表 $J(\theta_j)$ 对 $\theta$的偏导。</p>
<p>对于这个偏导，我们可以很容易的求解：</p>
<script type="math/tex; mode=display">

  \begin{align}
    \frac{\delta}{\delta\theta_j}J(\theta) & = \frac{\delta}{\delta\theta_j}J(\theta) \\
    & =   \frac{\delta}{\delta\theta_j}(1/2m\sum_{i=1}^m (h(x^i)-y^i)^2) \\
    & =  1/m(\sum_{i=1}^m (h(x^i)-y^i)x_j^i)
  \end{align}</script><p>向量化表示：</p>
<script type="math/tex; mode=display">
    \frac{\delta}{\delta\theta_j}J(\theta)  = 1/m(\sum_{i=1}^m (h(x^i)-y^i)x_j^i)</script><script type="math/tex; mode=display">
     \begin{align}
        \frac{\delta}{\delta\theta}J(\theta) &=
        \begin{bmatrix}
           \frac{\delta}{\delta\theta_1}J(\theta) \\ \frac{\delta}{\delta\theta_2}J(\theta) \\
           ...\\
           \frac{\delta}{\delta\theta_n}J(\theta)
        \end{bmatrix} \\

      & = 1/m \;\sum_{i=1}^m
      \begin{bmatrix}  (h(x^i)-y^i)x_1^i \\
        (h(x^i)-y^i)x_2^i\\
      ...\\
      (h(x^i)-y^i)x_n^i
       \end{bmatrix} \\

      & = 1/m\sum_{i=1}^m((h(x^i)-y^i)x^i) \\

      & = 1/m\;X^T(h(X)-y) \\
      & = 1/m\;X^T(X\theta - y)

      \end{align}</script><p>所以根据gradient descent：</p>
<script type="math/tex; mode=display">
  for \;i \;in \;range(niteration):\\
      \qquad \theta = \theta - \alpha/m\;X^T(X\theta - y)</script><h4 id="normal-equation-least-square"><a href="#normal-equation-least-square" class="headerlink" title="normal equation(least square)"></a>normal equation(least square)</h4><p>normal equation 其实就是解方程，使得梯度为0即达到最优值，上面我们已经求出梯度表达式：</p>
<script type="math/tex; mode=display">
1/m\;X^T(X\theta - y)</script><p>令它为0可求：</p>
<script type="math/tex; mode=display">
\begin{align}

 1/m\;X^T(X\theta - y) &= 0\\
 X^TX\theta & = X^Ty \\
 \theta &= (X^TX)^{-1}X^Ty
\end{align}</script><p>如此一来，不需迭代，直接根据输入的X和y求得预测函数</p>
<p>除了上面这种解法求梯度，还有两种方法：</p>
<h4 id="直接矩阵求导"><a href="#直接矩阵求导" class="headerlink" title="直接矩阵求导"></a>直接矩阵求导</h4><script type="math/tex; mode=display">
\begin{align}

  J(\theta) &= 1/2m(X\theta-y)^T(X\theta-y) \\
  \frac{\delta}{\delta\theta}J(\theta) &= 1/2m(2\frac{\delta}{\delta\theta}(X\theta-y)^T) (X\theta-y)\\
  & = 1/mX^T(X\theta-y)

\end{align}</script><h4 id="利用矩阵的迹求导"><a href="#利用矩阵的迹求导" class="headerlink" title="利用矩阵的迹求导"></a>利用矩阵的迹求导</h4><script type="math/tex; mode=display">
  J(\theta) = 1/2m(X\theta-y)^T(X\theta-y)</script><p>这是一个标量，所以它的迹即为它本身，所以我们可以直接用迹来求解：</p>
<script type="math/tex; mode=display">
\begin{align}
tr J(\theta) &= 1/2m tr(X\theta-y)^T(X\theta-y)\\
             &= 1/2mtr(\theta^TX^T-y^T)(X\theta-y)\\
             &= 1/2mtr(\theta^TX^TX\theta - y^TX\theta-\theta^TX^Ty-y^Ty) \\
=> \\
\frac{\delta}{\delta\theta}J(\theta)
  &= 1/2m\frac{\delta}{\delta\theta}tr(\theta^TX^TX\theta - y^TX\theta-\theta^TX^Ty-y^Ty) \\
  &= 1/2m\frac{\delta}{\delta\theta}tr(\theta^TX^TX\theta - 2y^TX\theta)\\
  &= 1/2m(X^TX\theta +X^TX\theta -2X^Ty)  \\
  &= 1/m(X^TX\theta - X^Ty)
\end{align}</script><h2 id="python代码实现"><a href="#python代码实现" class="headerlink" title="python代码实现"></a>python代码实现</h2><h3 id="基本numpy函数解释"><a href="#基本numpy函数解释" class="headerlink" title="基本numpy函数解释"></a>基本numpy函数解释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">1.</span> np.insert(X,<span class="number">0</span>,<span class="number">1</span>,axis=<span class="number">1</span>):</div><div class="line">    X: numpy narray</div><div class="line">    <span class="number">0</span>: 插入的位置</div><div class="line">    <span class="number">1</span>：初始化的值</div><div class="line">    axis：<span class="number">0</span>为row，<span class="number">1</span>为col</div><div class="line"><span class="number">2.</span> np.random.random((x,y))</div><div class="line">    (row,col) 随机生成值为(<span class="number">0</span>,<span class="number">1</span>)，大小为row*col的数组</div><div class="line"></div><div class="line"><span class="number">3.</span> X.dot：矩阵乘法</div><div class="line">   X.T ： 矩阵转置</div><div class="line">   np.linalg.pinv:矩阵求伪逆</div></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinearRegression</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    params:    </div><div class="line">    n_iterations:</div><div class="line">    learning_rate:</div><div class="line">    gradient_descent:</div><div class="line">    """</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_iterations=<span class="number">100</span>, learning_rate=<span class="number">0.01</span>, gradient_descent=True )</span>:</span></div><div class="line">        self.w = <span class="keyword">None</span></div><div class="line">        self.n_iterations = n_iterations</div><div class="line">        self.learning_rate = learning_rate</div><div class="line">        self.gradient_descent = gradient_descent</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self,X,y)</span>:</span></div><div class="line">        <span class="comment"># X :m*n =&gt; m*(n+1) for bias weight</span></div><div class="line">        X = np.insert(X,<span class="number">0</span>,<span class="number">1</span>,axis=<span class="number">1</span>)</div><div class="line">        <span class="comment"># gradient descent</span></div><div class="line">        <span class="keyword">if</span> self.gradient_descent :</div><div class="line">            n_features = np.shape(X)[<span class="number">1</span>]</div><div class="line">            self.w = np.random.random((n_features,))  <span class="comment"># 注意这里col还不能填1</span></div><div class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.n_iterations):</div><div class="line">                w_gradient = X.T.dot(X.dot(self.w)-y)</div><div class="line">                self.w = self.w - self.learning_rate * w_gradient</div><div class="line">        <span class="comment"># normal equation  </span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.w = (np.linalg.pinv(X.T.dot(X))).dot(X.T.dot(y))</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self,X)</span>:</span></div><div class="line">        X = np.insert(X,<span class="number">0</span>,<span class="number">1</span>,axis=<span class="number">1</span>)</div><div class="line">        y_pred = X.dot(self.w)</div><div class="line">        <span class="keyword">return</span> y_pred</div></pre></td></tr></table></figure>
<h3 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</div><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</div><div class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</div><div class="line">X,y = datasets.make_regression(n_features=<span class="number">1</span>,n_samples=<span class="number">200</span>,bias=<span class="number">100</span>,noise=<span class="number">5</span>)</div><div class="line">X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="number">0.2</span>)</div><div class="line"></div><div class="line"><span class="comment">#clf = MyLinearRegression(gradient_descent=False)</span></div><div class="line">clf = MyLinearRegression(n_iterations=<span class="number">100</span>)</div><div class="line">clf.fit(X_train,y_train)</div><div class="line">y_pred = clf.predict(X_test)</div><div class="line">mse = mean_squared_error(y_pred,y_test)</div><div class="line">print(mse)</div><div class="line">clf2 = linear_model.LinearRegression()</div><div class="line">clf2.fit(X_train,y_train)</div><div class="line">y_pred2 = clf2.predict(X_test)</div><div class="line">mse2 = mean_squared_error(y_pred2,y_test)</div><div class="line">print(mse2)</div><div class="line"></div><div class="line">clf3 = DecisionTreeRegressor(max_depth=<span class="number">20</span>)</div><div class="line">clf3.fit(X_train,y_train)</div><div class="line">mse3 = mean_squared_error(clf3.predict(X_test),y_test)</div><div class="line">print(mse3)</div></pre></td></tr></table></figure>
<p>可以从结果中看出，在数据集较小的情况下三个效果差不多，说明我们的算法没有问题。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="why-choose-least-squares"><a href="#why-choose-least-squares" class="headerlink" title="why choose least squares"></a>why choose least squares</h3><h3 id="Locally-weighted-linear-regression"><a href="#Locally-weighted-linear-regression" class="headerlink" title="Locally weighted linear regression"></a>Locally weighted linear regression</h3><h3 id="non-parametric-algorithm-and-parametric-algorithm"><a href="#non-parametric-algorithm-and-parametric-algorithm" class="headerlink" title="non-parametric algorithm and parametric algorithm"></a>non-parametric algorithm and parametric algorithm</h3><p>这三个问题比较上面略微复杂，直接看参考资料中Andrew Ng的讲义。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95" target="_blank" rel="external">wiki：最小二乘法</a></li>
<li><a href="https://en.wikipedia.org/wiki/Likelihood_function" target="_blank" rel="external">wiki：似然函数</a></li>
<li><a href="http://dawenl.github.io/files/mat_deriv.pdf" target="_blank" rel="external">矩阵的迹公式证明1</a></li>
<li><a href="http://math.stackexchange.com/questions/277151/prove-that-gradient-of-operatornametra-cdot-b-cdot-at-cdot-c-with-r?rq=1" target="_blank" rel="external">矩阵的迹公式证明2</a></li>
<li><a href="https://wenku.baidu.com/view/a90e4c61453610661ed9f479" target="_blank" rel="external">矩阵求导</a></li>
<li><a href="https://github.com/eriklindernoren/ML-From-Scratch/blob/master/supervised_learning/linear_regression.py" target="_blank" rel="external">github 上linearRegession的实现</a></li>
<li><a href="http://cs229.stanford.edu/notes/cs229-notes1.pdf" target="_blank" rel="external">Andrew Ng 关于Linear regression和logistic Regression的讲义</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xl2013.github.io/2017/03/07/算法（二）：二叉搜索树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/naruto.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/07/算法（二）：二叉搜索树/" itemprop="url">
                  算法(二)：二叉搜索树
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-07T20:02:31+08:00">
                2017-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、性质"><a href="#一、性质" class="headerlink" title="一、性质"></a>一、性质</h3><p>二叉搜索树是以一颗二叉树来组织的。对任何节点x，其左子树的关键字不大于x.key，其右子树的关键字不小于x.key（二叉搜索树性质）。</p>
<p>二叉搜索树的基本操作和一般的二叉树类似，分为查询操作（找到x节点，x节点的前驱，后继等等），增删操作。但是二叉搜索树和一般的二叉树不同，二叉搜索树操作的耗时与二叉树的高度相关，一般为O(h)。而普通二叉树需要遍历整个树，耗时为O(n)。相比下，二叉搜索树耗时大大减少。</p>
<p>由于二叉搜索树性质，所以各种操作也有相应的特点。</p>
<h3 id="二、查询操作"><a href="#二、查询操作" class="headerlink" title="二、查询操作"></a>二、查询操作</h3><ol>
<li>找到二叉搜索树种的x节点，这很简单，直接上代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function">TreeNode <span class="title">search</span><span class="params">(TreeNode root,<span class="keyword">int</span> val)</span></span>&#123;</div><div class="line"></div><div class="line">		<span class="keyword">while</span>(root!=<span class="keyword">null</span>&amp;&amp;root.val!=val)&#123;</div><div class="line">			<span class="keyword">if</span>(root.val&lt;val)</div><div class="line">				root=root.right;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				root=root.left;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li>找到前驱：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">TreeNode <span class="title">successor</span><span class="params">(TreeNode node)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</div><div class="line">			<span class="keyword">return</span> minimum(node.right);</div><div class="line">		TreeNode parent=node.parent;</div><div class="line">		<span class="comment">//如果node==parent.left，且node无右子树，则很明显，node的后继为其parent</span></div><div class="line">		<span class="keyword">while</span>(parent!=<span class="keyword">null</span>&amp;&amp;node==parent.right)&#123;</div><div class="line">			node=parent;</div><div class="line">			parent=parent.parent;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> parent;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>x节点的后继为第一个比x节点大的节点，由二叉搜索树性质，可知：如果x节点有右子树，则x节点的后继则为右子树中最小的节点。如果x节点没有右子树，因为x节点的左子树都比x节点小，所以只能往x节点的祖先去找 了。如果x节点是父节点的左子树，因为父节点的右子树节点比父节点和左子树节点都大，所以父节点必是x节点的后继。如果x节点是父节点的右子树，则只能继续往父节点的祖先去找。直到找到x节点为父节点的左子树为止。</p>
<p>3.前驱（类似后继）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">TreeNode <span class="title">predecessor</span><span class="params">(TreeNode node)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</div><div class="line">		<span class="keyword">return</span> maximum(node.left);</div><div class="line">	TreeNode parent=node.parent;</div><div class="line">	<span class="keyword">while</span>(parent!=<span class="keyword">null</span>&amp;&amp;node==parent.left)&#123;</div><div class="line">		node=parent;</div><div class="line">		parent=parent.parent;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> parent;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>最小节点最大节点:</li>
</ol>
<p>由于二叉搜索树的性质，可以很简单的找出树中的最大关键字元素和最小的关键字元素即最左或最右。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回最小的关键字元素</span></div><div class="line">	<span class="function">TreeNode <span class="title">minimum</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">while</span>(root.left!=<span class="keyword">null</span>)&#123;</div><div class="line">			root=root.left;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//返回最大的关键字元素</span></div><div class="line">	<span class="function">TreeNode <span class="title">maximum</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">while</span>(root.right!=<span class="keyword">null</span>)&#123;</div><div class="line">			root=root.right;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="三、插入操作"><a href="#三、插入操作" class="headerlink" title="三、插入操作"></a>三、插入操作</h3><p>插入一个节点也很简单，如果当前节点比需插入的节点大，则往该节点的左子树插入，直到发现空节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//向二叉搜索树中插入元素</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Tree tree,TreeNode node)</span></span>&#123;</div><div class="line">	TreeNode temp=<span class="keyword">null</span>;</div><div class="line">	TreeNode root=tree.root;</div><div class="line"></div><div class="line">	<span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</div><div class="line">		<span class="keyword">if</span>(root.val&lt;node.val)&#123;</div><div class="line">			temp=root;</div><div class="line">			root=root.right;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>&#123;</div><div class="line">			temp=root;</div><div class="line">			root=root.left;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	node.parent=temp;</div><div class="line">	<span class="keyword">if</span>(temp==<span class="keyword">null</span>)<span class="comment">//树为空</span></div><div class="line">		tree.root=node;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(temp.val&lt;node.val)</div><div class="line">		temp.right=node;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		temp.left=node;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在编写该函数时，我发现有两种解决方法，一种是遍历树，找到可插入的空节点后直接插入。另一种是遍历树，找到可插入的空节点后，保存节点信息，然后在进行插入操作。上诉代码就是第二种方法，而我第一次写的是第一种方法。仔细想了下，第二种方法其实更好，它将寻找插入节点和插入两种操作代码分隔开来，降低了代码的耦合度。而我的那种方法直接将两种操作合二为一，代码看起来既繁琐又不美观。以后要注意将不同操作解耦的思想。（先明确有多少种操作，在明确是否可以将操作分隔进行）</p>
<h3 id="四、删除操作"><a href="#四、删除操作" class="headerlink" title="四、删除操作"></a>四、删除操作</h3><p>删除是二叉搜索树中比较麻烦的一种操作。在删除节点的过程中，由于该节点可能还有子节点，所以还需对树的结构进行调整。具体先分为4种情况：</p>
<ol>
<li>该节点的右子树为空</li>
<li>该节点的左子树为空</li>
<li>该节点的左右子树都不为空</li>
<li>该节点的左右子树都为空</li>
</ol>
<p>1,2两种情况都类似，直接将节点的非空子树与该节点调换即可。由于需涉及了很多子树调换操作，所以为了解耦，直接将该操作模块化(注意边界情况)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个是用子树v代替子树u</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transplant</span><span class="params">(Tree tree,TreeNode u,TreeNode v)</span></span>&#123;</div><div class="line">		<span class="comment">//如果u是树的根</span></div><div class="line">		<span class="keyword">if</span>(u.parent==<span class="keyword">null</span>)&#123;</div><div class="line">			tree.root=v;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(u==u.parent.left)&#123;</div><div class="line">			u.parent.left=v;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(u==u.parent.right)</div><div class="line">			u.parent.right=v;</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(v!=<span class="keyword">null</span>)</div><div class="line">			v.parent=u.parent;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>仔细思考下，第四种情况和1,2类似，直接将空子树和节点即可。所以第四种情况包含在1,2中，之后不需为之编写代码。再考虑第三种情况：该节点左右子树都不为空。如果像1,2中情况直接将子树对换的话，势必会丢失另一子树的信息，所以必须对结构进行调整。那么怎么调整呢，可以想到先摘出一个子树作为另一子树中一个节点的子树，那么就变成了1,2中的情况。摘出左右都行，这里选择摘出左子树。</p>
<p>假设摘出了左子树，那么该怎么选择右子树中的节点呢？其实很简单，因为右子树中的节点都比左子树大，所以摘出的左子树可直接作为右子树中节点的左子树。那么问题就变成了找出右子树中的左孩子为空的节点，而左孩子为空，则表明该节点是右子树中最小的节点。</p>
<p>这样做是可以保证树的二叉搜索树性质，但是可以发现，每删除一个节点，树的高度就会增大许多。这是因为直接将删除节点的左子树插入到右子树最左节点，很明显，树的高度增加了许多。为了防止这种情况，需要调整删除后的树的结构。</p>
<p>需要调整的情况分为两种：一是右子树的最左节点即为删除节点的右孩子，这种情况下不需调整，高度最多变化1。<br>二是右子树的最左节点不为删除节点的右孩子，这种情况如果不调整，高度变化最大为左子树的高度，所以需要调整。<br>这里设删除节点为x，左子树根节点（x左孩子）为l，右子树根节点为r，则右子树的最小节点为y=minimum(r);调整代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(y!=r)&#123;</div><div class="line">    transplant(T,y,y.right);</div><div class="line">    y.right=r;</div><div class="line">    r.parent=y;</div><div class="line">&#125;</div><div class="line">y.left=x.left;</div><div class="line">x.left.parent=y;</div><div class="line">transplant(T,x,y);</div></pre></td></tr></table></figure></p>
<p>第二种情况下，做出这样的调整：将y和它的右子树对换，这样摘出了y节点。然后将y节点作为x节点左右子树的父节点。如此一来相当于x和y节点对换，高度最多变化1。</p>
<p>综上删除节点的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Tree tree,TreeNode root)</span></span>&#123;</div><div class="line">		<span class="comment">//case:a</span></div><div class="line">		<span class="keyword">if</span>(root.left==<span class="keyword">null</span>)&#123;</div><div class="line">			transplant(tree,root, root.right);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//case:b</span></div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(root.right==<span class="keyword">null</span>)&#123;</div><div class="line">			transplant(tree,root, root.left);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>&#123;</div><div class="line">			TreeNode minimumNode=minimum(root.right);</div><div class="line">			<span class="comment">//case :d</span></div><div class="line">			<span class="keyword">if</span>(minimumNode!=root.right)&#123;</div><div class="line">				transplant(tree, minimumNode, minimumNode.right);</div><div class="line">				minimumNode.right=root.right;</div><div class="line">				root.right.parent=minimumNode;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			<span class="comment">//case :c</span></div><div class="line">			minimumNode.left=root.left;</div><div class="line">			root.left.parent=minimumNode;</div><div class="line">			transplant(tree, root, minimumNode);</div><div class="line">		&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>在删除操作了解到，光保持二叉搜索树性质有时候还不够，还需要保持树的高度，保证在进行插入删除操作时，树的高度不能增长太快，毕竟二叉搜索树的操作的效率和树的高度有关（都是O(n)）。</p>
<p>在4中的删除操作进行了一定调整来保证树高，但是不能总是保证树的高度合理。并且在插入过程中没有做出任何措施去维护树高。为了保证树的平均高度，可以通过“随机构建二叉搜索树”即插入的过程是随机的，还可以通过创建一个新的性质的二叉搜索树-<strong>红黑树</strong>。详情见《算法：红黑树》</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xl2013.github.io/2017/03/07/算法（一）：分治、动态规划与贪心算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/naruto.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/07/算法（一）：分治、动态规划与贪心算法/" itemprop="url">
                  算法(一)：分治、动态规划与贪心算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-07T20:02:31+08:00">
                2017-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>可能这里需要分开讲解三种算法，然后这里写他们的联系与区别以及什么时候使用。</p>
</blockquote>
<p>每个算法的标识问题</p>
<p>分治：</p>
<ul>
<li>[ ] 归并排序</li>
<li>[ ] 最大子数组</li>
</ul>
<p>动态规划：</p>
<ul>
<li>[ ] 最长公共子序列</li>
<li>[ ] 最长回文子序列</li>
<li>[ ] 钢条切割问题</li>
<li>[ ] 最大子数组</li>
</ul>
<p>贪心：</p>
<ul>
<li>[ ] 活动选择问题</li>
<li>[ ] huffman问题</li>
</ul>
<hr>
<h3 id="一、分治"><a href="#一、分治" class="headerlink" title="一、分治"></a>一、分治</h3><blockquote>
<p>分治就是把大的问题分解成互不相交的子问题，递归的求解子问题，然后把子问题的解组合起来</p>
</blockquote>
<p>分治策略解决问题，分为三个步骤：</p>
<ol>
<li>分解：将问题划分为子问题，子问题和原问题一样，只是规模更小</li>
<li>解决：步骤递归的求解子问题，如果子问题的规模够小，则停止递归，直接求解</li>
<li>合并：将子问题的解直接合并成原问题的解</li>
</ol>
<p>在使用分治策略解决问题的时候，最重要的步骤就是分解问题。在划分子问题的时候，有的时候一般会出现与原问题不一样的问题，如果出现了，那么这个问题一般可以直接求解。如果这个问题不能直接求解，那么可能子问题的划分不合理，需要重新考虑。</p>
<p>以归并排序为例，我们需要对数组进行排序。那么原问题就是数组排序，如果我们把数组分为几部分，分别对数组进行排序，那么原问题就划分为子数组的排序问题。当子数组排序完毕，即子问题解决完毕，则进行合并，将子问题的解合并成原问题的解。伪代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(arr,left,right)</span></span>&#123;</div><div class="line"> <span class="comment">//子问题的规模最小，停止递归</span></div><div class="line"> <span class="keyword">if</span>(left==right) <span class="keyword">return</span> arr[left];</div><div class="line"><span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</div><div class="line"><span class="comment">//划分子问题，递归求解</span></div><div class="line">sort(arr,left,mid);</div><div class="line">sort(arr,mid+<span class="number">1</span>,right);</div><div class="line"><span class="comment">//求解完毕，合并子问题的解</span></div><div class="line">merge(arr,left,mid,right);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再以最大子数组为例，要得到最大连续子数组，我们可以先划分成两个子数组的最大连续子数组的问题。但是我们发现，最大连续子数组还可能出现在两个子数组之间，所以又出现了新的问题：求解包含子数组之间的最大连续数组。我们可以发现，这个问题我们可以直接求解，而不需要再次递归求解。所以原问题的划分成功，我们得到了两个和原问题一致的子问题和一个可直接求解的问题。这样，我们就可以编码解决了。</p>
<p>从这两个问题中，我们可以发现，分治策略是把原问题划分为规模更小的子问题。但是，我们需要注意的是，这两些子问题都是==不相交==的。同一层的子问题不涉及到另一个。那么，如果划分出的子问题之间存在==重叠==(即不同子问题拥有公共子问题)怎么办呢，如果继续使用分治策略，则会出现大量的重复计算的问题，导致耗时大幅增加。</p>
<p>为了解决重复计算的问题，我们把已计算的子问题的解保存起来，当需使用的 时候不需再次计算，直接使用。这样的方法，我们称为动态规划（dynamic programming）。</p>
<h3 id="二、动态规划-DP"><a href="#二、动态规划-DP" class="headerlink" title="二、动态规划(DP)"></a>二、动态规划(DP)</h3><blockquote>
<p>动态规划通常用于最优解问题。</p>
</blockquote>
<p>动态规划和分治类似，都需划分子问题，求解子问题，然后合并子问题的解。但是不同的是，划分出的子问题存在重叠，为了不重复计算，动态规划算法只对子问题计算一次，并且保存其值。</p>
<p>动态规划通常有以下四个步骤：</p>
<ol>
<li>刻画一个最优解的结构特征（得到子问题的状态，即如何表示子问题的最优解）（分治没有具体表示）</li>
<li>递归的定义最优解的值（得到状态转移方程（递归求解公式））  （分治：概念表示）</li>
<li>计算最优解的值（自顶向下（备忘录）（递归），自底向上（通常选用））（类似分治中的归并）</li>
<li>利用计算出的信息构造最优解（如果只需要最优解的值，则不需要此步骤）</li>
</ol>
<p>上溯4个步骤中，1,2是最重要的。通常，得到子问题的最优解结构和递归求解公式，该DP问题就已解决。在别的资料中，也称为“找出子问题的状态和状态转移方程”。经典的DP问题有钢铁切割问题和最长公共子序列问题等，为了和分治比较，这里继续采用最大子数组作为例子。在分析该例之前，先学习一下动态规划原理：</p>
<h4 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h4><p>动态规划的第一步就是刻画最优解结构。如果一个问题的最优解包含其子问题的最优解，那么我们就称该问题具有最优子结构。在使用动态规划方法时，我们需要使用子问题的最优解来构造原问题的最优解，所以我们需要考察最优解中使用的所有子问题。以下是发掘最优子结构性质的通用模式：</p>
<ol>
<li>做出一次选择。做出这次选择会产生一个或或多个待解问题。</li>
<li>假定该选择得到最优解。</li>
<li>确定最优解选择后，可以确定子问题，以及如何最好的刻画子问题空间</li>
<li>利用“剪切-粘贴”（cut-paste）技术证明：作为构成原问题最优解的构成部分，每个子问题的解就是它本身的最优解。</li>
</ol>
<p>在发掘最优子结构的过程中，我们就已经刻画出了最优解的特征。所以这4个步骤也是在求解最优解问题时，首先应该做的。另外一个判断是否能用dp的性质是子问题的无关性。如果两个子问题不同时占用同一资源的话，我们就称两个子问题是无关的。如果子问题之间不是无关的，那么这个问题就不能用DP来解决。</p>
<h4 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h4><p>适合动态规划求解的最优解问题应该具备的第二个性质是子问题空间必须足够小，即问题的递归算法会反复的求解相同的问题，而不是一直生成新的子问题。如果递归算法反复求解相同的子问题，我们就称最优化问题具有“重叠子问题”的性质。与之相对应的是，适合用分治解决的问题通常在每一步都生成不同的子问题。动态规划算法通常利用重叠子问题的性质，对每个子问题求解一次，并把每次的结果存入一个表中，当再次需要这个值时直接读表即可，每次查表的时间为常数。</p>
<p>在了解了动态规划原理（使用动态规划的原因）后，我们再对最大子数组进行分析。首先先回顾最大子数组问题：</p>
<blockquote>
<p>给定一个整数数组，数组值有正数和负数。求数组中的和最大的连续子数组。</p>
</blockquote>
<p>第一步：刻画最优解的结构特征。我们先使用发掘最优子结构的四个步骤：</p>
<ol>
<li>做出一次选择。我们先选择a[i]最为连续子数组的最后一位。</li>
<li>假设该选择得到最优解。我们假设f[i]为选择a[i]为最后一位后的最优解即最大和。</li>
<li>确定子问题，刻画子问题空间。a[i-1]在最优解中，那么f[i]=f[i-1]+a[i].如果不在，则f[i]=a[i];那么原问题产生了一个子问题</li>
<li>利用“剪切-粘贴”原理证明：作为构成原问题最优解的构成部分，每个子问题的解就是它本身的最优解。</li>
</ol>
<p>假设f[i-1]不是子问题的最优解，那么存在f’[i-1]&gt;f[i-1]，因为两者都是以a[i-1]为结尾，所以f’[i-1]+a[i]&gt;f[i-1]+a[i]，所以f[i]不是最优解，与原假设矛盾。</p>
<p>综合上诉4步，我们确定了问题的最优子结构性质，而且同时也得到了最优解结构和递归求解公式。</p>
<p>第二步：递归定义最优解的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f[i]=  f[i-1]+a[i]   f[i-1]&gt;0</div><div class="line"></div><div class="line">    =  a[i]          f[i-1]&lt;0</div></pre></td></tr></table></figure>
<p>(如果f[i-1]&lt; 0,那么a[i-1]必不在f[i]的最优解中)</p>
<p>第三步：计算最优解的值</p>
<ol>
<li><p>备忘录（自顶向下）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">f[]=-A;</div><div class="line">f[<span class="number">0</span>]=a[<span class="number">0</span>];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxSubArr</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> []a)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(f[i]&gt;-A)&#123;</div><div class="line">        <span class="keyword">return</span> f[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(getMaxSubArr(i-<span class="number">1</span>,a)&gt;<span class="number">0</span>)</div><div class="line">     f[i]=a[i]+f[i-<span class="number">1</span>];</div><div class="line">    <span class="keyword">else</span></div><div class="line">     f[i]=a[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>自底向上</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxSubArr</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> []f=<span class="keyword">new</span> <span class="keyword">int</span>[a.length];</div><div class="line">    f[<span class="number">0</span>]=a[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(f[i-<span class="number">1</span>]&lt;<span class="number">0</span>)</div><div class="line">            f[i]=a[i];</div><div class="line">        <span class="keyword">else</span></div><div class="line">            f[i]=f[i-<span class="number">1</span>]+a[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max(f);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常情况下，在每个子问题都求解的情况下，自底向下必备忘录算法快（省去了递归的开销）。但是当有的子问题不必求解的时候，备忘录方法比自底向下快，因为备忘录方法只会求解必要的子问题。</p>
<p>第四步：构造最优解</p>
<p>构造最优解通常有两种方法，一是根据解的表来构造（即根据f[i]），二是在计算最优解的值时，顺便记录。</p>
<ol>
<li><p>根据f[i]:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> []f)</span></span>&#123;    </div><div class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;f.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(f[i]&gt;f[max])&#123;</div><div class="line">            max=i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    print(f,max);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> []f,<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span>(f[index]&gt;<span class="number">0</span>)&#123;</div><div class="line">        print(f,index-<span class="number">1</span>)</div><div class="line">        System.out.print(f[i]+<span class="string">" "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>顺便记录：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxSubArr</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> []f=<span class="keyword">new</span> <span class="keyword">int</span>[a.length];</div><div class="line">    f[<span class="number">0</span>]=a[<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> []begin=<span class="keyword">new</span> <span class="keyword">int</span>[a.length];</div><div class="line">    <span class="keyword">int</span> end=<span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sum=f[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(f[i-<span class="number">1</span>]&lt;<span class="number">0</span>)&#123;</div><div class="line">            f[i]=a[i];</div><div class="line">            begin[i]=i;</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            f[i]=f[i-<span class="number">1</span>]+a[i];</div><div class="line">        <span class="keyword">if</span>(sum&lt;f[i])&#123;</div><div class="line">            sum=f[i];</div><div class="line">            end=i;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> []begin,<span class="keyword">int</span> end,<span class="keyword">int</span>[]a)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> b=begin[end];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=b;i&lt;=end;i++)</div><div class="line">        System.out.print(a[i]+<span class="string">","</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两种方法都可以，一般在使用第二种的时候要多维护一个表。</p>
<p>总的来说，动态规划步骤中，总是要经历选择。算法本身不筛选选择，而是比较选择后的子问题的最优解从而得到原问题的最优解。动态规划算法的复杂度与子问题的个数和选择的个数成线性相关。以钢条切割为例，以跟n长的钢条，则一共有n个子问题，子问题中最大的选择个数为n，则动态规划的算法复杂度为O(n^2).以最大子数组为例，长度为n的数组，一共有n个子问题，但是只有一种选择，即最后一个数字为最优解的子数组的结尾。所以算法复杂度为O(n)。</p>
<p>那么，如果有一种选择可以使每次都得到最优解，算法复杂度就可以得到减少。这种选择就是“贪心”选择</p>
<h3 id="三、贪心"><a href="#三、贪心" class="headerlink" title="三、贪心"></a>三、贪心</h3><blockquote>
<p>贪心选择性质：通过做出局部最优（贪心）的选择来构造全局最优解。</p>
</blockquote>
<p>贪心算法通过做出一系列选择来求出问题的最优解。在每个决策点，它做出当时看起来最佳的选择。这种启发式策略并不能保证找到最优解。但是对有些问题确实有效，比如活动选择问题。贪心算法是基于动态规划算法的，每个贪心算法背后都有一个更繁琐的动态规划算法。</p>
<p>贪心算法的设计过程如下：</p>
<ol>
<li>确定问题的最优解结构（和动态规划一致）</li>
<li>设计一个递归算法（递归求解公式）(状态转移方程)（和动态规划一致）</li>
<li>证明如果我们做出一个贪心选择，则只剩一个子问题</li>
<li>证明贪心选择总是安全的（3,4步骤可以调换）</li>
<li>设计一个递归算法实现贪心策略</li>
<li>将递归算法改成迭代算法</li>
</ol>
<p>从贪心算法的设计步骤我们可以看出，1,2步骤和动态规划一致，3,4是贪心算法最重要的部分。如何做出一个贪心选择，和证明这个贪心选择是安全的使我们在使用贪心算法时最重要的两个步骤。那么上诉7个步骤可以简化话如下：</p>
<ol>
<li>将最优化问题转化为这样的形式：对其做出一次选择后只剩下一个子问题求解</li>
<li>证明做出贪心选择后，原问题总是存在最优解（即贪心选择包含在原问题最优解中）（安全的贪心策略）</li>
<li>证明做出贪心选择后剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解（即动态规划里的最优子结构性质）</li>
</ol>
<p>以活动选择为例，我们使用上诉三个步骤创建贪心算法。</p>
<ol>
<li>我们每次选择结束时间最早的活动a[k]，那么s[k]为在a[k]结束后的活动的集合，令A[k]为s[k]的最大兼容活动集。则做出选择后，只剩一个问题，在s[k]中求出A[k]</li>
<li>设a[j]是A[k]中最早结束的活动，a[m]是s[k]中最早结束的活动。令A’[k]=(A[k]-a[j])Ua[k],因为A[k]中的活动互不相交，且a[j]是A[k]中结束最早的活动，f[m]&lt;=f[j],所以A[k]=A’[k]。所以A’[k]也是s[k]的一个最大兼容活动集，且它包含a[m]</li>
<li>假设A[k]不是s[k]的最优解，A’[k]是s[k]的最优解。那么A’[k]+a[k]&lt;A[k]+a[k],则与原问题为最优解矛盾，所以存在最优子结构性质。</li>
</ol>
<p>由上诉三个步骤，可以得到递归算法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">activitySelect</span><span class="params">(<span class="keyword">int</span>[]s,<span class="keyword">int</span>[]f,k,n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> m=k+<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(m&lt;n&amp;&amp;s[m]&lt;f[k])</div><div class="line">        m++;</div><div class="line">    <span class="keyword">if</span>(m&lt;n)</div><div class="line">        <span class="keyword">return</span> activitySelect(s,f,m,n)+<span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>改进成迭代算法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">activitySelect</span><span class="params">(<span class="keyword">int</span>[]s,<span class="keyword">int</span>[]f)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(s.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> max=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(s[i]&gt;f[k])&#123;</div><div class="line">            max++;</div><div class="line">            k=i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xl2013.github.io/2017/03/07/java（四）：内部类详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/naruto.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/07/java（四）：内部类详解/" itemprop="url">
                  java(四)：内部类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-07T20:01:38+08:00">
                2017-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、内部类"><a href="#一、内部类" class="headerlink" title="一、内部类"></a>一、内部类</h3><blockquote>
<p>一个类定义在另一个类中， 这就叫内部类<br>内部类的对象默认持有创建它的那个封装类的一个对象的句柄</p>
</blockquote>
<h4 id="1-内部类可以隐藏实施细节"><a href="#1-内部类可以隐藏实施细节" class="headerlink" title="1.内部类可以隐藏实施细节"></a>1.内部类可以隐藏实施细节</h4><p>如果普通的定义一个内部类，那么内部类没什么特别的地方。然而，当我们准备上溯造型到一个基础类（特别是到一个接口）的时候，内部类就开始发挥其关键作用（从用于实现的对象生成一个接口句柄具有与上溯造型至一个基础类相同的效果）。这是由于内部类随后可完全进入不可见或不可用状态——对任何人都将如此。所以我们可以非常方便地隐藏实施细节。我们得到的全部回报就是一个基础类或者接口的句柄，而且甚至有可能不知道准确的类型。就象下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Destination</span> </span>&#123;</div><div class="line">  <span class="function">String <span class="title">readLabel</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel3</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span> <span class="keyword">extends</span> <span class="title">Contents</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span></span></div><div class="line">      <span class="keyword">implements</span> <span class="title">Destination</span> &#123;</div><div class="line">    <span class="keyword">private</span> String label;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span> </span>&#123;</div><div class="line">      label = whereTo;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> Destination <span class="title">dest</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> Contents <span class="title">cont</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PContents();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Parcel3 p = <span class="keyword">new</span> Parcel3();</div><div class="line">    Contents c = p.cont();</div><div class="line">    Destination d = p.dest(<span class="string">"Tanzania"</span>);</div><div class="line">    <span class="comment">// Illegal -- can't access private class: Parcel3.PContents c = p.new PContents();</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，Contents和Destination代表可由客户程序员使用的接口（记住接口会将自己的所有成员都变成public属性）。为方便起见，它们置于单独一个文件里，但原始的Contents和Destination在它们自己的文件中是相互public的。</p>
<p>在Parcel3中，一些新东西已经加入：内部类PContents被设为private，所以除了Parcel3之外，其他任何东西都不能访问它。PDestination被设为protected，所以除了Parcel3，Parcel3包内的类（因为protected也为包赋予了访问权；也就是说，protected也是“友好的”），以及Parcel3的继承者之外，其他任何东西都不能访问PDestination。这意味着客户程序员对这些成员的认识与访问将会受到限制。</p>
<p>事实上，我们甚至不能下溯造型到一个private内部类（或者一个protected内部类，除非自己本身便是一个继承者），因为我们不能访问名字，就象在classTest里看到的那样。所以，利用private内部类，类设计人员可完全禁止其他人依赖类型编码，并可将具体的实施细节完全隐藏起来。除此以外，从客户程序员的角度来看，一个接口的范围没有意义的，因为他们不能访问不属于公共接口类的任何额外方法。这样一来，Java编译器也有机会生成效率更高的代码。</p>
<h4 id="2-内部类拥有封装类对象的一个引用：链接到外部类"><a href="#2-内部类拥有封装类对象的一个引用：链接到外部类" class="headerlink" title="2.内部类拥有封装类对象的一个引用：链接到外部类"></a>2.内部类拥有封装类对象的一个引用：链接到外部类</h4><p>迄今为止，我们见到的内部类好象仅仅是一种名字隐藏以及代码组织方案。尽管这些功能非常有用，但似乎并不特别引人注目。然而，我们还忽略了另一个重要的事实。创建自己的内部类时，那个类的对象同时拥有指向封装对象（这些对象封装或生成了内部类）的一个链接。所以它们能访问那个封装对象的成员——毋需取得任何资格。除此以外，内部类拥有对封装类所有元素的访问权限（注释②）。</p>
<p>下面这个例子阐示了这个问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</div><div class="line">  <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Object[] o;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">    o = <span class="keyword">new</span> Object[size];</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(next &lt; o.length) &#123;</div><div class="line">      o[next] = x;</div><div class="line">      next++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> i == o.length;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> o[i];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span>(i &lt; o.length) i++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> Selector <span class="title">getSelector</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SSelector();</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Sequence s = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div><div class="line">      s.add(Integer.toString(i));</div><div class="line">    Selector sl = s.getSelector();    </div><div class="line">    <span class="keyword">while</span>(!sl.end()) &#123;</div><div class="line">      System.out.println((String)sl.current());</div><div class="line">      sl.next();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上诉代码中我们可以看出，SSelector内部类可以引用外部类的成员变量Object[]o，从而实现了序列容器的迭代迭代功能。其实，翻看java源代码中的容器类，其中大部分的容器的迭代功能都是通过内部类实现iterator接口来实现的。比如ArrayList：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">       <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></div><div class="line">       <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></div><div class="line">       <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> cursor != size;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">           checkForComodification();</div><div class="line">           <span class="keyword">int</span> i = cursor;</div><div class="line">           <span class="keyword">if</span> (i &gt;= size)</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">           Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</div><div class="line">           <span class="keyword">if</span> (i &gt;= elementData.length)</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">           cursor = i + <span class="number">1</span>;</div><div class="line">           <span class="keyword">return</span> (E) elementData[lastRet = i];</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">           checkForComodification();</div><div class="line"></div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               ArrayList.<span class="keyword">this</span>.remove(lastRet);</div><div class="line">               cursor = lastRet;</div><div class="line">               lastRet = -<span class="number">1</span>;</div><div class="line">               expectedModCount = modCount;</div><div class="line">           &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * An optimized version of AbstractList.ListItr</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">       ListItr(<span class="keyword">int</span> index) &#123;</div><div class="line">           <span class="keyword">super</span>();</div><div class="line">           cursor = index;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> cursor != <span class="number">0</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> cursor;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> cursor - <span class="number">1</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</div><div class="line">           checkForComodification();</div><div class="line">           <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</div><div class="line">           <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">           Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</div><div class="line">           <span class="keyword">if</span> (i &gt;= elementData.length)</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">           cursor = i;</div><div class="line">           <span class="keyword">return</span> (E) elementData[lastRet = i];</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">           <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">           checkForComodification();</div><div class="line"></div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               ArrayList.<span class="keyword">this</span>.set(lastRet, e);</div><div class="line">           &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">           checkForComodification();</div><div class="line"></div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               <span class="keyword">int</span> i = cursor;</div><div class="line">               ArrayList.<span class="keyword">this</span>.add(i, e);</div><div class="line">               cursor = i + <span class="number">1</span>;</div><div class="line">               lastRet = -<span class="number">1</span>;</div><div class="line">               expectedModCount = modCount;</div><div class="line">           &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>然后通过公有方法上溯造型来得到iterator,这样得到的迭代器是符合容器特性的容器，而且还隐藏了具体的实施细节，让使用者可以忽略iterator在不同容器的实现区别而统一使用定义的接口方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Returns an iterator over the elements in this list in proper sequence.</div><div class="line">   *</div><div class="line">   * &lt;p&gt;The returned iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</div><div class="line">   *</div><div class="line">   * <span class="doctag">@return</span> an iterator over the elements in this list in proper sequence</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Itr();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>我们现在知道一个内部类可以访问封装类的成员。这是如何实现的呢？内部类必须拥有对封装类的特定对象的一个引用，而封装类的作用就是创建这个内部类。随后，当我们引用封装类的一个成员时，就利用那个（隐藏）的引用来选择那个成员。幸运的是，编译器会帮助我们照管所有这些细节。但我们现在也可以理解内部类的一个对象只能与封装类的一个对象联合创建。在这个创建过程中，要求对封装类对象的句柄进行初始化。若不能访问那个句柄，编译器就会报错。进行所有这些操作的时候，大多数时候都不要求程序员的任何介入。</p>
<h3 id="二、方法和作用域中的内部类"><a href="#二、方法和作用域中的内部类" class="headerlink" title="二、方法和作用域中的内部类"></a>二、方法和作用域中的内部类</h3><p>至此，我们已基本理解了内部类的典型用途。对那些涉及内部类的代码，通常表达的都是“单纯”的内部类，非常简单，且极易理解。然而，内部类的设计非常全面，不可避免地会遇到它们的其他大量用法——假若我们在一个方法甚至一个任意的作用域内创建内部类。有两方面的原因促使我们这样做：</p>
<ol>
<li>正如前面展示的那样，我们准备实现某种形式的接口，使自己能创建和返回一个句柄。</li>
<li>要解决一个复杂的问题，并希望创建一个类，用来辅助自己的程序方案。同时不愿意把它公开。</li>
</ol>
<p>在下面这个例子里，将修改前面的代码，以便使用：</p>
<ol>
<li>在一个方法内定义的类</li>
<li>在方法的一个作用域内定义的类</li>
<li>一个匿名类，用于实现一个接口</li>
<li>一个匿名类，用于扩展拥有非默认构建器的一个类</li>
<li>一个匿名类，用于执行字段初始化</li>
<li>一个匿名类，通过实例初始化进行构建（匿名内部类不可拥有构建器）</li>
</ol>
<p>所有这些都在innerscopes包内发生。首先，来自前述代码的通用接口会在它们自己的文件里获得定义，使它们能在所有的例子里使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//: Destination.java</span></div><div class="line"><span class="keyword">package</span> c07.innerscopes;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Destination</span> </span>&#123;</div><div class="line">  <span class="function">String <span class="title">readLabel</span><span class="params">()</span></span>;</div><div class="line">&#125; <span class="comment">///:~</span></div></pre></td></tr></table></figure></p>
<p>由于我们已认为Contents可能是一个抽象类，所以可采取下面这种更自然的形式，就象一个接口那样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//: Contents.java</span></div><div class="line"><span class="keyword">package</span> c07.innerscopes;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Contents</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125; <span class="comment">///:~</span></div></pre></td></tr></table></figure></p>
<p>尽管是含有具体实施细节的一个普通类，但Wrapping也作为它所有衍生类的一个通用“接口”使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//: Wrapping.java</span></div><div class="line"><span class="keyword">package</span> c07.innerscopes;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; i = x; &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">&#125; <span class="comment">///:~</span></div></pre></td></tr></table></figure></p>
<p>在上面的代码中，我们注意到Wrapping有一个要求使用自变量的构建器，这就使情况变得更加有趣了。</p>
<p>第一个例子展示了如何在一个方法的作用域（而不是另一个类的作用域）中创建一个完整的类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//: Parcel4.java</span></div><div class="line"><span class="comment">// Nesting a class within a method</span></div><div class="line"><span class="keyword">package</span> c07.innerscopes;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel4</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> Destination <span class="title">dest</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span></span></div><div class="line">        <span class="keyword">implements</span> <span class="title">Destination</span> &#123;</div><div class="line">      <span class="keyword">private</span> String label;</div><div class="line">      <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span> </span>&#123;</div><div class="line">        label = whereTo;</div><div class="line">      &#125;</div><div class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Parcel4 p = <span class="keyword">new</span> Parcel4();</div><div class="line">    Destination d = p.dest(<span class="string">"Tanzania"</span>);</div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">///:~</span></div></pre></td></tr></table></figure></p>
<p>PDestination类属于dest()的一部分，而不是Parcel4的一部分（同时注意可为相同目录内每个类内部的一个内部类使用类标识符PDestination，这样做不会发生命名的冲突）。因此，PDestination不可从dest()的外部访问。请注意在返回语句中发生的上溯造型——除了指向基础类Destination的一个句柄之外，没有任何东西超出dest()的边界之外。当然，不能由于类PDestination的名字置于dest()内部，就认为在dest()返回之后PDestination不是一个有效的对象。</p>
<p>下面这个例子展示了如何在任意作用域内嵌套一个内部类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//: Parcel5.java</span></div><div class="line"><span class="comment">// Nesting a class within a scope</span></div><div class="line"><span class="keyword">package</span> c07.innerscopes;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(b) &#123;</div><div class="line">      <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> String id;</div><div class="line">        TrackingSlip(String s) &#123;</div><div class="line">          id = s;</div><div class="line">        &#125;</div><div class="line">        <span class="function">String <span class="title">getSlip</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</div><div class="line">      &#125;</div><div class="line">      TrackingSlip ts = <span class="keyword">new</span> TrackingSlip(<span class="string">"slip"</span>);</div><div class="line">      String s = ts.getSlip();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Can't use it here! Out of scope:</span></div><div class="line">    <span class="comment">//! TrackingSlip ts = new TrackingSlip("x");</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span> </span>&#123; internalTracking(<span class="keyword">true</span>); &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Parcel5 p = <span class="keyword">new</span> Parcel5();</div><div class="line">    p.track();</div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">///:~</span></div></pre></td></tr></table></figure></p>
<p>TrackingSlip类嵌套于一个if语句的作用域内。这并不意味着类是有条件创建的——它会随同其他所有东西得到编译。然而，在定义它的那个作用域之外，它是不可使用的。除这些以外，它看起来和一个普通类并没有什么区别。</p>
<p>下面这个例子看起来有些奇怪：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//: Parcel6.java</span></div><div class="line"><span class="comment">// A method that returns an anonymous inner class</span></div><div class="line"><span class="keyword">package</span> c07.innerscopes;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> Contents <span class="title">cont</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">    &#125;; <span class="comment">// Semicolon required in this case</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Parcel6 p = <span class="keyword">new</span> Parcel6();</div><div class="line">    Contents c = p.cont();</div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">///:~</span></div></pre></td></tr></table></figure></p>
<p>cont()方法同时合并了返回值的创建代码，以及用于表示那个返回值的类。除此以外，这个类是匿名的——它没有名字。而且看起来似乎更让人摸不着头脑的是，我们准备创建一个Contents对象：</p>
<p>return new Contents()<br>但在这之后，在遇到分号之前，我们又说：“等一等，让我先在一个类定义里再耍一下花招”：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这种奇怪的语法要表达的意思是：“创建从Contents衍生出来的匿名类的一个对象”。由new表达式返回的句柄会自动上溯造型成一个Contents句柄。匿名内部类的语法其实要表达的是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContents</span> <span class="keyword">extends</span> <span class="title">Contents</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyContents();</div></pre></td></tr></table></figure></p>
<p>在匿名内部类中，Contents是用一个默认构建器创建的。下面这段代码展示了基础类需要含有自变量的一个构建器时做的事情：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//: Parcel7.java</span></div><div class="line"><span class="comment">// An anonymous inner class that calls the</span></div><div class="line"><span class="comment">// base-class constructor</span></div><div class="line"><span class="keyword">package</span> c07.innerscopes;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrap</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    <span class="comment">// Base constructor call:</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x) &#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.value() * <span class="number">47</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;; <span class="comment">// Semicolon required</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Parcel7 p = <span class="keyword">new</span> Parcel7();</div><div class="line">    Wrapping w = p.wrap(<span class="number">10</span>);</div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">///:~</span></div></pre></td></tr></table></figure></p>
<p>也就是说，我们将适当的自变量简单地传递给基础类构建器，在这儿表现为在“new Wrapping(x)”中传递x。匿名类不能拥有一个构建器，这和在调用super()时的常规做法不同。</p>
<p>在前述的两个例子中，分号并不标志着类主体的结束（和C++不同）。相反，它标志着用于包含匿名类的那个表达式的结束。因此，它完全等价于在其他任何地方使用分号。</p>
<p>若想对匿名内部类的一个对象进行某种形式的初始化，此时会出现什么情况呢？由于它是匿名的，没有名字赋给构建器，所以我们不能拥有一个构建器。然而，我们可在定义自己的字段时进行初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//: Parcel8.java</span></div><div class="line"><span class="comment">// An anonymous inner class that performs</span></div><div class="line"><span class="comment">// initialization. A briefer version</span></div><div class="line"><span class="comment">// of Parcel5.java.</span></div><div class="line"><span class="keyword">package</span> c07.innerscopes;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel8</span> </span>&#123;</div><div class="line">  <span class="comment">// Argument must be final to use inside</span></div><div class="line">  <span class="comment">// anonymous inner class:</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Destination <span class="title">dest</span><span class="params">(<span class="keyword">final</span> String dest)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</div><div class="line">      <span class="keyword">private</span> String label = dest;</div><div class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Parcel8 p = <span class="keyword">new</span> Parcel8();</div><div class="line">    Destination d = p.dest(<span class="string">"Tanzania"</span>);</div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">///:~</span></div></pre></td></tr></table></figure></p>
<p>若试图定义一个匿名内部类，并想使用在匿名内部类外部定义的一个对象，则编译器要求外部对象为final属性。这正是我们将dest()的自变量设为final的原因。如果忘记这样做，就会得到一条编译期出错提示。</p>
<p>只要自己只是想分配一个字段，上述方法就肯定可行。但假如需要采取一些类似于构建器的行动，又应怎样操作呢？通过Java 1.1的实例初始化，我们可以有效地为一个匿名内部类创建一个构建器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//: Parcel9.java</span></div><div class="line"><span class="comment">// Using "instance initialization" to perform</span></div><div class="line"><span class="comment">// construction on an anonymous inner class</span></div><div class="line"><span class="keyword">package</span> c07.innerscopes;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel9</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> Destination</span></div><div class="line">  <span class="title">dest</span><span class="params">(<span class="keyword">final</span> String dest, <span class="keyword">final</span> <span class="keyword">float</span> price)</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">int</span> cost;</div><div class="line">      <span class="comment">// Instance initialization for each object:</span></div><div class="line">      &#123;</div><div class="line">        cost = Math.round(price);</div><div class="line">        <span class="keyword">if</span>(cost &gt; <span class="number">100</span>)</div><div class="line">          System.out.println(<span class="string">"Over budget!"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">private</span> String label = dest;</div><div class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Parcel9 p = <span class="keyword">new</span> Parcel9();</div><div class="line">    Destination d = p.dest(<span class="string">"Tanzania"</span>, <span class="number">101.395F</span>);</div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">///:~</span></div></pre></td></tr></table></figure></p>
<p>在实例初始化模块中，我们可看到代码不能作为类初始化模块（即if语句）的一部分执行。所以实际上，一个实例初始化模块就是一个匿名内部类的构建器。当然，它的功能是有限的；我们不能对实例初始化模块进行过载处理，所以只能拥有这些构建器的其中一个。</p>
<p>上诉就是匿名内部的使用规则及方法，实际上我们队匿名内部类的使用非常常见及广泛，比如我们经常使用的线程类0可以这样使用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;			</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				System.out.print(<span class="string">"t1"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">t1.start();</div></pre></td></tr></table></figure></p>
<p>还有android中经常使用到的actionlistenner等等。</p>
<h3 id="三、静态内部类"><a href="#三、静态内部类" class="headerlink" title="三、静态内部类"></a>三、静态内部类</h3><p>为正确理解static在应用于内部类时的含义，必须记住内部类的对象默认持有创建它的那个封装类的一个对象的句柄。然而，假如我们说一个内部类是static的，这种说法却是不成立的。static内部类意味着：<br>(1) 为创建一个static内部类的对象，我们不需要一个外部类对象。<br>(2) 不能从static内部类的一个对象中访问一个外部类对象。<br>但在存在一些限制：由于static成员只能位于一个类的外部级别，所以内部类不可拥有static数据或static内部类。</p>
<p>倘若为了创建内部类的对象而不需要创建外部类的一个对象，那么可将所有东西都设为static。为了能正常工作，同时也必须将内部类设为static。如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//: Parcel10.java</span></div><div class="line"><span class="comment">// Static inner classes</span></div><div class="line"><span class="keyword">package</span> c07.parcel10;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Destination</span> </span>&#123;</div><div class="line">  <span class="function">String <span class="title">readLabel</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel10</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span></span></div><div class="line">  <span class="keyword">extends</span> <span class="title">Contents</span> &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span></span></div><div class="line">      <span class="keyword">implements</span> <span class="title">Destination</span> &#123;</div><div class="line">    <span class="keyword">private</span> String label;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span> </span>&#123;</div><div class="line">      label = whereTo;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Destination <span class="title">dest</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Contents <span class="title">cont</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PContents();</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Contents c = cont();</div><div class="line">    Destination d = dest(<span class="string">"Tanzania"</span>);</div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">///:~</span></div></pre></td></tr></table></figure></p>
<p>在main()中，我们不需要Parcel10的对象；相反，我们用常规的语法来选择一个static成员，以便调用将句柄返回Contents和Destination的方法。</p>
<p>通常，我们不在一个接口里设置任何代码，但static内部类可以成为接口的一部分。由于类是“静态”的，所以它不会违反接口的规则——static内部类只位于接口的命名空间内部：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//: IInterface.java</span></div><div class="line"><span class="comment">// Static inner classes inside interfaces</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IInterface</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i, j, k;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">///:~</span></div></pre></td></tr></table></figure></p>
<h3 id="四、内部类的覆盖"><a href="#四、内部类的覆盖" class="headerlink" title="四、内部类的覆盖"></a>四、内部类的覆盖</h3><p>若创建一个内部类，然后从封装类继承，并重新定义内部类，那么会出现什么情况呢？也就是说，我们有可能覆盖一个内部类吗？这看起来似乎是一个非常有用的概念，但“覆盖”一个内部类——好象它是外部类的另一个方法——这一概念实际不能做任何事情：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//: BigEgg.java</span></div><div class="line"><span class="comment">// An inner class cannot be overriden</span></div><div class="line"><span class="comment">// like a method</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span> </span>&#123;</div><div class="line">  <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Egg.Yolk()"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">private</span> Yolk y;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Egg</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"New Egg()"</span>);</div><div class="line">    y = <span class="keyword">new</span> Yolk();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"BigEgg.Yolk()"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> BigEgg();</div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">///:~</span></div></pre></td></tr></table></figure></p>
<p>默认构建器是由编译器自动合成的，而且会调用基础类的默认构建器。大家或许会认为由于准备创建一个BigEgg，所以会使用Yolk的“被覆盖”版本。但实际情况并非如此。输出如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">New <span class="title">Egg</span><span class="params">()</span></span></div><div class="line">Egg.<span class="title">Yolk</span><span class="params">()</span></div></pre></td></tr></table></figure></p>
<p>这个例子简单地揭示出当我们从外部类继承的时候，没有任何额外的内部类继续下去。然而，仍然有可能“明确”地从内部类继承：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//: BigEgg2.java</span></div><div class="line"><span class="comment">// Proper inheritance of an inner class</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg2</span> </span>&#123;</div><div class="line">  <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Egg2.Yolk()"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Egg2.Yolk.f()"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">private</span> Yolk y = <span class="keyword">new</span> Yolk();</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Egg2</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"New Egg2()"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertYolk</span><span class="params">(Yolk yy)</span> </span>&#123; y = yy; &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; y.f(); &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg2</span> <span class="keyword">extends</span> <span class="title">Egg2</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> <span class="keyword">extends</span> <span class="title">Egg2</span>.<span class="title">Yolk</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"BigEgg2.Yolk()"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"BigEgg2.Yolk.f()"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BigEgg2</span><span class="params">()</span> </span>&#123; insertYolk(<span class="keyword">new</span> Yolk()); &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Egg2 e2 = <span class="keyword">new</span> BigEgg2();</div><div class="line">    e2.g();</div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">///:~</span></div></pre></td></tr></table></figure></p>
<p>现在，BigEgg2.Yolk明确地扩展了Egg2.Yolk，而且覆盖了它的方法。方法insertYolk()允许BigEgg2将它自己的某个Yolk对象上溯造型至Egg2的y句柄。所以当g()调用y.f()的时候，就会使用f()被覆盖版本。输出结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Egg2.Yolk()</div><div class="line"><span class="function">New <span class="title">Egg2</span><span class="params">()</span></span></div><div class="line">Egg2.<span class="title">Yolk</span><span class="params">()</span></div><div class="line">BigEgg2.<span class="title">Yolk</span><span class="params">()</span></div><div class="line">BigEgg2.Yolk.<span class="title">f</span><span class="params">()</span></div></pre></td></tr></table></figure></p>
<p>对Egg2.Yolk()的第二个调用是BigEgg2.Yolk构建器的基础类构建器调用。调用<br>g()的时候，可发现使用的是f()的被覆盖版本。</p>
<h3 id="五、内部类的标识符"><a href="#五、内部类的标识符" class="headerlink" title="五、内部类的标识符"></a>五、内部类的标识符</h3><p>由于每个类都会生成一个.class文件，用于容纳与如何创建这个类型的对象有关的所有信息（这种信息产生了一个名为Class对象的元类），所以大家或许会猜到内部类也必须生成相应的.class文件，用来容纳与它们的Class对象有关的信息。这些文件或类的名字遵守一种严格的形式：先是封装类的名字，再跟随一个$，再跟随内部类的名字。例如，由InheritInner.java创建的.class文件包括：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">InheritInner.class</div><div class="line">WithInner$Inner.class</div><div class="line">WithInner.class</div></pre></td></tr></table></figure></p>
<p>如果内部类是匿名的，那么编译器会简单地生成数字，把它们作为内部类标识符使用。若内部类嵌套于其他内部类中，则它们的名字简单地追加在一个$以及外部类标识符的后面。</p>
<p>这种生成内部名称的方法除了非常简单和直观以外，也非常“健壮”，可适应大多数场合的要求（注释③）。由于它是Java的标准命名机制，所以产生的文件会自动具备“与平台无关”的能力（注意Java编译器会根据情况改变内部类，使其在不同的平台中能正常工作）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xl2013.github.io/2017/03/07/java（三）：构造器与多态性（多形性）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/naruto.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/07/java（三）：构造器与多态性（多形性）/" itemprop="url">
                  java（三）：构造器与多态性（多形性）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-07T20:01:38+08:00">
                2017-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、多态"><a href="#一、多态" class="headerlink" title="一、多态"></a>一、多态</h3><blockquote>
<p>多态：多种类型当做同一种类型对待。将发生改变的东西同没有发生改变的东西区分开</p>
</blockquote>
<h4 id="1-方法调用绑定"><a href="#1-方法调用绑定" class="headerlink" title="1.方法调用绑定"></a>1.方法调用绑定</h4><p>方法绑定，将一个方法调用同一个方法主体连接到一起就被称为“绑定”(binding)。如果在程序运行前执行绑定，就叫做“早期绑定”。c编译器只有早期绑定一种方法调用。在运行期进行，以对象为基础的方法绑定称为“后期绑定”，也可称为“动态绑定”。java中的所有方法都采用动态绑定，除非方法声明为final。</p>
<p>动态绑定的例子很常见，在笔记“上溯造型与下溯造型”中，可以看到具体的代码例子，这里不再赘述。java虚拟机怎么实现动态绑定的，可以见<a href="">笔记java虚拟机学习中的多态篇</a>。</p>
<h4 id="2-覆盖与重载（过载）"><a href="#2-覆盖与重载（过载）" class="headerlink" title="2.覆盖与重载（过载）"></a>2.覆盖与重载（过载）</h4><p>重载：方法名一样，但是参数不同的方法，指同一样东西在不同地方具有多种含义。覆盖：子类继承父类的方法，参数、名字、返回值都相同，但是具体实现不同，指只具有一种含义但是原先的含义被后来者替代。例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thinkInJava;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"Shape"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"Triangle"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"Rectangle"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(String val)</span></span>&#123;</div><div class="line">		System.out.println(val+<span class="string">": Rectangle"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Override</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Shape shape)</span></span>&#123;</div><div class="line">		shape.draw();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">		Triangle triangle=<span class="keyword">new</span> Triangle();</div><div class="line">		Rectangle rectangle=<span class="keyword">new</span> Rectangle();</div><div class="line">		Override.draw(triangle);</div><div class="line">		Override.draw(rectangle);</div><div class="line">		rectangle.draw(<span class="string">"overload"</span>);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在Shape的子类中draw方法被覆盖，在Triangle子类中，draw方法也被重载。编译器对被覆盖的draw方法的调用都是通过动态绑定的，所以可以正确的执行相应对象的函数。java通过方法覆盖实现多态，而重载与多态无关。</p>
<h3 id="二、构造器与多态"><a href="#二、构造器与多态" class="headerlink" title="二、构造器与多态"></a>二、构造器与多态</h3><p>由于衍生类继承基类，所以能访问基础类的任何public和protected成员，这意味着当我们使用衍生类成员时，必须假定基础类的所有成员都是有效的。为达到这个要求，则在对象的构造器调用之前，先调用基础类的构造器，以保证基础类的成员先被初始化。初始化的过程如下：</p>
<p>(1) 在采取其他任何操作之前，为对象分配的存储空间初始化成二进制0；</p>
<p>(2) 调用基类构造器</p>
<p>(3) 按声明顺序调用成员初始化代码</p>
<p>(4) 调用衍生类构造器主体</p>
<p>下面这个例子很好的体现了初始化过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thinkInJava;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Monster</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Monster</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">		System.out.println(getHP());</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getHP</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">extends</span> <span class="title">Monster</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> HP=<span class="number">1</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">()</span></span>&#123;</div><div class="line">		HP=<span class="number">5</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getHP</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> HP;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitOrder</span> </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">			Boss boss=<span class="keyword">new</span> Boss();</div><div class="line">			System.out.println(boss.getHP());</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line">输出：<span class="number">0</span>   <span class="number">1</span>  <span class="number">5</span></div></pre></td></tr></table></figure></p>
<p>可以看到为对象分配空间，并初始化为0。然后调用基础类的构造器，在这里根据多态，调用的getHP为子类Boss的getHP。因为子类的成员初始化还没执行且被初始为0，所以返回的是0。之后执行的是成员初始化代码，所以HP的值被初始化为1.然后调用的是衍生类的构造器，打印1，而且HP被赋值为5。如此一来，对象的构造完成。接下来执行对象的方法，打印的就是赋值后的HP5了。</p>
<p>注意，在调用构造器之前先执行的是成员初始化代码。</p>
<h3 id="三、扩展-通过继承来设计"><a href="#三、扩展-通过继承来设计" class="headerlink" title="三、扩展:通过继承来设计"></a>三、扩展:通过继承来设计</h3><p>这里就直接copy thinkInJava 中的内容，因为这部分对我们如何设计对象还是有帮助的。</p>
<p>学习了多形性的知识后，由于多形性是如此“聪明”的一种工具，所以看起来似乎所有东西都应该继承。但<br>假如过度使用继承技术，也会使自己的设计变得不必要地复杂起来。事实上，当我们以一个现成类为基础建<br>立一个新类时，如首先选择继承，会使情况变得异常复杂。</p>
<p>一个更好的思路是首先选择“合成” —— 如果不能十分确定自己应使用哪一个。合成不会强迫我们的程序设<br>计进入继承的分级结构中。同时，合成显得更加灵活，因为可以动态选择一种类型（以及行为），而继承要<br>求在编译期间准确地知道一种类型。下面这个例子对此进行了阐释：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//: Transmogrify.java</span></div><div class="line"><span class="comment">// Dynamically changing the behavior of</span></div><div class="line"><span class="comment">// an object via composition.</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Actor</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">act</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HappyActor</span> <span class="keyword">implements</span> <span class="title">Actor</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"HappyActor"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SadActor</span> <span class="keyword">implements</span> <span class="title">Actor</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"SadActor"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stage</span> </span>&#123;</div><div class="line">Actor a = <span class="keyword">new</span> HappyActor();</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123; a = <span class="keyword">new</span> SadActor(); &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123; a.act(); &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmogrify</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Stage s = <span class="keyword">new</span> Stage();</div><div class="line">s.go(); <span class="comment">// Prints "HappyActor"</span></div><div class="line">s.change();</div><div class="line">s.go(); <span class="comment">// Prints "SadActor"</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，一个 Stage 对象包含了指向一个 Actor 的句柄，后者被初始化成一个 HappyActor 对象。这意味着<br>go()会产生特定的行为。但由于句柄在运行期间可以重新与一个不同的对象绑定或结合起来，所以SadActor<br>对象的句柄可在 a 中得到替换，然后由 go()产生的行为发生改变。这样一来，我们在运行期间就获得了很大<br>的灵活性。与此相反，我们不能在运行期间换用不同的形式来进行继承；它要求在编译期间完全决定下来。<br>一条常规的设计准则是：用继承表达行为间的差异，并用成员变量表达状态的变化。在上述例子中，两者都<br>得到了应用：继承了两个不同的类，用于表达 act()方法的差异；而 Stage 通过合成技术允许它自己的状态<br>发生变化。在这种情况下，那种状态的改变同时也产生了行为的变化。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xl2013.github.io/2017/03/07/java（一）：上溯造型与下溯造型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/naruto.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/07/java（一）：上溯造型与下溯造型/" itemprop="url">
                  java（一）：上溯造型与下溯造型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-07T20:01:38+08:00">
                2017-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、上溯造型"><a href="#一、上溯造型" class="headerlink" title="一、上溯造型"></a>一、上溯造型</h3><blockquote>
<p>上溯造型：把衍生类型当做它的基本类型处理</p>
</blockquote>
<p>我们在学习面向对象的时候都已经习惯将子类当做父类类型去处理。在面向对象的概念中，这过程叫做上溯造型。在C++和Java中，上溯造型有点不同。在java中，一个类型还可以上溯造型到它实现的接口。在初学java的时候，没懂这一点导致很多代码看不懂。所以，接下来将有一个代码示例来展示上溯造型到父类和实现的接口的过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thinkInJava;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHuman</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"Human"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eat</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eatFruit</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sleep</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sleepInBed</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMan</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.print(<span class="string">"man"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Man</span> <span class="keyword">implements</span> <span class="title">Eat</span>,<span class="title">Sleep</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleepInBed</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"son.sleepInBed"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatFruit</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"son.eatFruit"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Upcasting</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useMan</span><span class="params">(Man man)</span></span>&#123;</div><div class="line">		man.printMan();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useHuman</span><span class="params">(Human human)</span></span>&#123;</div><div class="line">		human.printHuman();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">		ArrayList&lt;Eat&gt; eats=<span class="keyword">new</span> ArrayList&lt;Eat&gt;();</div><div class="line">		ArrayList&lt;Sleep&gt; sleeps=<span class="keyword">new</span> ArrayList&lt;Sleep&gt;();</div><div class="line">		Son son1=<span class="keyword">new</span> Son();</div><div class="line">		Son son2=<span class="keyword">new</span> Son();</div><div class="line">		eats.add(son1);</div><div class="line">		eats.add(son2);</div><div class="line">		sleeps.add(son2);</div><div class="line">		sleeps.add(son1);</div><div class="line">		<span class="keyword">for</span>(Eat eat : eats)&#123;</div><div class="line">			eat.eatFruit();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(Sleep sleep :sleeps)&#123;</div><div class="line">			sleep.sleepInBed();</div><div class="line">		&#125;</div><div class="line">		useHuman(son1);</div><div class="line">		useMan(son2);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在代码中我们可以看到，Son类继承了Man和Human，实现了接口Eat和Sleep。在使用中，我们既可以将son对象当做Eat接口、Sleep接口使用，也可以当做父类和祖父类使用。</p>
<p>上溯造型 是安全的类型转换，在代码中以eats为例，我们将son1和son2加入到eats中，这时son将只剩eat的方法可以使用，本身的其他方法不可见，这样即保证了类型转换的安全。另外，在useMan（）中，我们并不能确定传递进的参数为Man，所以涉及到新的问题：运行时类型判定，这点我们下次再学习。</p>
<h3 id="二、下溯造型"><a href="#二、下溯造型" class="headerlink" title="二、下溯造型"></a>二、下溯造型</h3><blockquote>
<p>下溯造型：</p>
</blockquote>
<p>相比于上溯造型，下溯造型未必是安全的。当一个父类对象想下溯造型至子类对象时，就会报java.lang.ClassCastException。例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Man man=<span class="keyword">new</span> Man();</div><div class="line">Son son=(Son)man;</div></pre></td></tr></table></figure></p>
<p>我们什么时候会用到下溯造型呢，比如在useMan()中，我们函数参数是man，但是我们可能传递的是son对象，这时我们如果需要使用son的函数，就需要把man下溯造型至son。因为如前面所言，上溯造型时，本身的方法不可见，如需使用本身的方法，必须下溯造型至本身。<br>在使用下溯造型时，我们一般要加一个保障措施，就是先判断对象是否是所需下溯造型类的实例。即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(man <span class="keyword">instanceof</span> Son)&#123;</div><div class="line">    Son son=(Son)man;</div><div class="line">    son.printSon();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外，对于父类，本身，实现的接口，instanceof返回都是true。所以如果需要判断对象是哪个类的直接实例，需从最下级开始使用instanceof判断，第一个返回true的即是其直接实例。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xl2013.github.io/2017/03/07/java（二）：运行期类型检查与反射/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/naruto.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/07/java（二）：运行期类型检查与反射/" itemprop="url">
                  java（二）：运行期类型检查与反射
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-07T20:01:38+08:00">
                2017-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、运行类型检查"><a href="#一、运行类型检查" class="headerlink" title="一、运行类型检查"></a>一、运行类型检查</h3><blockquote>
<p>RTTI(Run Time Type Indetify):运行时类型鉴定：当只有一个基础类句柄时，判断对象的正确类型</p>
</blockquote>
<p>迄今为止，我们已知的RTTI形式包括：<br>(一)、 经典造型，如（Shape），它用来保证造型的正确性，并在遇到失败造型时，报出 ClassCastException违例<br>(二)、 代表对象类型的Class对象。可查询Class对象，获取有用的运行期资料。</p>
<p>对于这两种RTTI形式，第一种是我们不需要考虑，是由编译器去实现。第二种，java中采取“反射”的技术，通过得到Class对象来回去类的所有信息，从而可以判断类型。</p>
<h3 id="二、反射：-运行期类信息"><a href="#二、反射：-运行期类信息" class="headerlink" title="二、反射： 运行期类信息"></a>二、反射： 运行期类信息</h3><p>我们可以通过代码获取Class对象，如果已有对象，则可以通过getclass得到class对象。如果没有对象，则通过ClassForName来得到class对象。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thinkInJava;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflection</span> </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</div><div class="line">			String name=<span class="string">"paperfan"</span>;</div><div class="line">			Class cls1=name.getClass();</div><div class="line">			Class cls2=Class.forName(<span class="string">"java.lang.String"</span>);</div><div class="line">			System.out.println(<span class="string">"cls1:"</span>+cls1.getName());</div><div class="line">			System.out.println(<span class="string">"cls2:"</span>+cls2.getName());</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>得到class对象后，我们可以得到的信息就非常多了，比如有函数getSuperclass()，可以得到父类。通过getINterfaces()，可以得到所有实现的接口。通过newInstance(),我们可以直接得到类的实例，一旦创建实例，就可以得到object句柄，但是这个句柄指向的是类对应的对象示例。所以，利用反射技术我们可以得到一个对象的所有信息。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xl2013.github.io/2017/03/07/Spring-AOP基础：代理模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/naruto.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/07/Spring-AOP基础：代理模式/" itemprop="url">
                  Spring AOP基础：代理模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-07T20:00:22+08:00">
                2017-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote>
<h4 id="代理模式：在对已有方法进行改进时，不直接修改原有方法或代码，而是提供第三方。该第三方含有代理角色的引用，并根据需求增加相应的功能。"><a href="#代理模式：在对已有方法进行改进时，不直接修改原有方法或代码，而是提供第三方。该第三方含有代理角色的引用，并根据需求增加相应的功能。" class="headerlink" title="代理模式：在对已有方法进行改进时，不直接修改原有方法或代码，而是提供第三方。该第三方含有代理角色的引用，并根据需求增加相应的功能。"></a>代理模式：在对已有方法进行改进时，不直接修改原有方法或代码，而是提供第三方。该第三方含有代理角色的引用，并根据需求增加相应的功能。</h4><p>代理模式在程序设计中有非常重要的应用，AOP就是针对代理的一种应用。在生活中代理也无处不在，比如翻墙，比如开代理打韩服等等。<br>学习代理模式，先从简单的代码开始。</p>
</blockquote>
<h5 id="先定义一个简单的接口"><a href="#先定义一个简单的接口" class="headerlink" title="先定义一个简单的接口"></a>先定义一个简单的接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span></span>&#123;</div><div class="line">     <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="再实现一个基本的Hello实现"><a href="#再实现一个基本的Hello实现" class="headerlink" title="再实现一个基本的Hello实现"></a>再实现一个基本的Hello实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span></span>&#123;</div><div class="line">    <span class="meta">@override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> sayHello&#123;</div><div class="line">        System.out.println(<span class="string">"Hello"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果要在println方法前分别需要一些处理逻辑，该怎么么做呢？如果是以前的我，我会直接将处理逻辑写死在在HelloImpl的sayHello方法中。但是这样的写法在大多数情况下是不妥的，就好像没学面向对象以前，将所有的方法逻辑写在一个类里面。这样的写法，会使得一个方法越来越长，处理逻辑的实现也会将类变得越来越庞大，而且这样处理逻辑可能与该类的其他方法无关。所以最好的方法是将这些处理逻辑交于代理处理。</p>
<h5 id="对于我们的HelloImpl类，我们写一个HelloProxy类，让该类调用HelloImpl的sayHello方法，并在调用的前后进行相应的逻辑处理。"><a href="#对于我们的HelloImpl类，我们写一个HelloProxy类，让该类调用HelloImpl的sayHello方法，并在调用的前后进行相应的逻辑处理。" class="headerlink" title="对于我们的HelloImpl类，我们写一个HelloProxy类，让该类调用HelloImpl的sayHello方法，并在调用的前后进行相应的逻辑处理。"></a>对于我们的HelloImpl类，我们写一个HelloProxy类，让该类调用HelloImpl的sayHello方法，并在调用的前后进行相应的逻辑处理。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProxy</span> <span class="keyword">implements</span> <span class="title">Hello</span></span>&#123;</div><div class="line">        Hello helloImpl;</div><div class="line">        HelloProxy()&#123;</div><div class="line">            helloImpl=<span class="keyword">new</span> HelloImpl();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</div><div class="line">            before();</div><div class="line">            helloImpl.sayHello();</div><div class="line">            after();</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</div><div class="line">            System.out.println(<span class="string">"before"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</div><div class="line">            System.out.println(<span class="string">"after"</span>);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这段代码中，我们用HelloProxy实现Hello接口（和HelloImpl实现相同的接口），并且在构造方法中new出HelloImpl实例，则我们可以在HelloProxy的sayHello()方法中调用HelloImpl的sayHello()方法。这样的话，我们就可以在调用前后添加相应的before和after方法，并在这两个方法中去实现相应的前后处理逻辑。</p>
<h5 id="我们再用main方法测试一下"><a href="#我们再用main方法测试一下" class="headerlink" title="我们再用main方法测试一下"></a>我们再用main方法测试一下</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        HelloProxy helloProxy=<span class="keyword">new</span> HelloProxy();</div><div class="line">        helloProxy.sayHello();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="结果如下"><a href="#结果如下" class="headerlink" title="结果如下"></a>结果如下</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">before</div><div class="line">hello</div><div class="line">after</div></pre></td></tr></table></figure>
<p>这个HelloProxy就是简单的代理。这样的代理称为静态代理。所谓静态，就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。<br>这样的静态代理几个缺点：</p>
<ol>
<li>如果要代理的方法很多,那么静态代理类的规模也势必很大。</li>
<li>如果接口增加一个方法，那么所有代理类也必须实现此方法，如此就增加了代码维护的复杂度</li>
</ol>
<p>为了解决静态代理的问题，我们使用JDK提供的动态代理方案DynamicProxy:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span>  <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Object object;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object object)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.object=object;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></div><div class="line">			<span class="keyword">throws</span> Throwable &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		before();</div><div class="line">		Object result=method.invoke(object, args);</div><div class="line">		after();</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"before"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"after"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>DynamicProxy实现了InvocationHandler接口，那么必须实现invoke方法，在invoke方法中，直接通过反射去调用被包装类的方法，在调用前后实现 分别处理before和after，最后将result返回。</p>
<h5 id="在main中测试："><a href="#在main中测试：" class="headerlink" title="在main中测试："></a>在main中测试：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">		Hello hello=<span class="keyword">new</span> HelloImpl();</div><div class="line">		DynamicProxy dynamicProxy=<span class="keyword">new</span> DynamicProxy(hello);</div><div class="line">		Hello helloProxy=(Hello) Proxy.newProxyInstance(hello.getClass().getClassLoader(), hello.getClass().getInterfaces(), dynamicProxy);</div><div class="line">		helloProxy.sayHello();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h5 id="结果如下："><a href="#结果如下：" class="headerlink" title="结果如下："></a>结果如下：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">before</div><div class="line">hello</div><div class="line">after</div></pre></td></tr></table></figure>
<p>在上述代码中，我们用这个通用的DynamicProxy类去包装HelloImpl实例，然后调用JDK给我们提供的Proxy类工厂方法newProxyInstance去动态的创建一个Hello接口的代理类，最后调用这个代理类的sayHello方法。结果和静态代理结果一样。<br>其实，动态代理就是动态生成XxxProxy。和静态代理相比，动态代理类的源码是在程序运行期间由JVM根据反射等机制动态生成的。<br>代理类和委托类的关系是在程序运行时确定的，所有如果需要在不同类的不同方法增加相同的处理逻辑，我们只需要一个动态代理类就可以实现，这就是动态代理的优点。<br>在main方法中我们可以看到，Proxy.newProxyInstance方法要有三个参数：</p>
<ol>
<li>ClassLoader;</li>
<li>该实现类的所有接口</li>
<li>动态代理对象</li>
</ol>
<p>在调用结束后还需要类型的强制转换。如果我们的动态代理需要代理多个对象，那么上述代码需要重复多次。</p>
<h5 id="为了避免Proxy-newInstance方法出现多次（减少代码量和简化动态代理类的使用），我们将动态代理对象实例化部分代码封装起来-使用泛型-："><a href="#为了避免Proxy-newInstance方法出现多次（减少代码量和简化动态代理类的使用），我们将动态代理对象实例化部分代码封装起来-使用泛型-：" class="headerlink" title="为了避免Proxy.newInstance方法出现多次（减少代码量和简化动态代理类的使用），我们将动态代理对象实例化部分代码封装起来(使用泛型)："></a>为了避免Proxy.newInstance方法出现多次（减少代码量和简化动态代理类的使用），我们将动态代理对象实例化部分代码封装起来(使用泛型)：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">()</span></span>&#123;		</div><div class="line">	<span class="keyword">return</span> (T)Proxy.newProxyInstance(object.getClass().getClassLoader(),</div><div class="line">			object.getClass().getInterfaces(), <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="如此一来，我们的DynamicProxy的使用将更加方便-代码也看起来简洁清晰多了："><a href="#如此一来，我们的DynamicProxy的使用将更加方便-代码也看起来简洁清晰多了：" class="headerlink" title="如此一来，我们的DynamicProxy的使用将更加方便,代码也看起来简洁清晰多了："></a>如此一来，我们的DynamicProxy的使用将更加方便,代码也看起来简洁清晰多了：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">		DynamicProxy dynamicProxy=<span class="keyword">new</span> DynamicProxy(<span class="keyword">new</span> HelloImpl());</div><div class="line">		Hello helloProxy=dynamicProxy.getProxy();</div><div class="line">		helloProxy.sayHello();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>除了减少代理类这个优点，相对于静态代理，动态代理在接口变化的时候，代理类不需要变化，而静态代理类则需要相对应的改动。<br>但是，我们发现，上述JDK动态代理只能代理有接口的类，如果需要代理的类没有接口，那么JDK动态代理就无用武之地。</p>
<h5 id="为了解决代理没有接口的类的问题，我们使用开源的CGLIB类库。"><a href="#为了解决代理没有接口的类的问题，我们使用开源的CGLIB类库。" class="headerlink" title="为了解决代理没有接口的类的问题，我们使用开源的CGLIB类库。"></a>为了解决代理没有接口的类的问题，我们使用开源的CGLIB类库。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLIBProxy</span> <span class="keyword">implements</span>  <span class="title">MethodInterceptor</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> CGLIBProxy instance=<span class="keyword">new</span> CGLIBProxy();</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">CGLIBProxy</span><span class="params">()</span> </span>&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CGLIBProxy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt;cls)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> (T)Enhancer.create(cls, <span class="keyword">this</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object target, Method method, Object[] args,</span></span></div><div class="line">			MethodProxy proxy) <span class="keyword">throws</span> Throwable &#123;</div><div class="line">		before();</div><div class="line">		Object result=proxy.invokeSuper(target, args);</div><div class="line">		after();</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"before"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"after"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述代码可以看出，CGLIB类库的使用和JDK动态代理类似。但是CGLIB类库可以代理没有接口的类，且速度相较于JDK DynamicProxy更快。</p>
<h5 id="测试使用及运行结果如下："><a href="#测试使用及运行结果如下：" class="headerlink" title="测试使用及运行结果如下："></a>测试使用及运行结果如下：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greet</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String str)</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"hello"</span>+str);</div><div class="line">	&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">		Greet greetProxy=CGLIBProxy.getInstance().getProxy(Greet.class);</div><div class="line">		greetProxy.say(<span class="string">"shan"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">运行结果：</div><div class="line">before</div><div class="line">helloshan</div><div class="line">after</div></pre></td></tr></table></figure>
<h4 id="至此，代理模式基本内容也就介绍完毕。AOP是基于JDK-DynamicProxy和CGLIB代理，但是又不仅限于这些。要学好spring，AOP是重中之重。而代理又是AOP的基石，所以对代理理解并学以致用才是王道。"><a href="#至此，代理模式基本内容也就介绍完毕。AOP是基于JDK-DynamicProxy和CGLIB代理，但是又不仅限于这些。要学好spring，AOP是重中之重。而代理又是AOP的基石，所以对代理理解并学以致用才是王道。" class="headerlink" title="至此，代理模式基本内容也就介绍完毕。AOP是基于JDK DynamicProxy和CGLIB代理，但是又不仅限于这些。要学好spring，AOP是重中之重。而代理又是AOP的基石，所以对代理理解并学以致用才是王道。"></a>至此，代理模式基本内容也就介绍完毕。AOP是基于JDK DynamicProxy和CGLIB代理，但是又不仅限于这些。要学好spring，AOP是重中之重。而代理又是AOP的基石，所以对代理理解并学以致用才是王道。</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xl2013.github.io/2017/03/07/Spring-AOP学习笔记（一）：PointCut、Advice及Advisor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/naruto.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/07/Spring-AOP学习笔记（一）：PointCut、Advice及Advisor/" itemprop="url">
                  Spring AOP学习笔记（一）：PointCut、Advice及Advisor
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-07T20:00:22+08:00">
                2017-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>前言：AOP学习笔记之方法拦截器（Advisor）。这些是AOP中很重要的概念</p>
</blockquote>
<h3 id="一、Advice"><a href="#一、Advice" class="headerlink" title="一、Advice"></a>一、Advice</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>要实现AOP的方法增强，首先要确定的是如何增强方法，也就是围绕方法调用注入我们新增加的方法。这里使用Advice（通知）概念，++定义在连接点做什么，为切面增强提供织入接口++。</p>
<h4 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h4><p>Advice是AOP联盟定义的一个接口，在Spring AOP实现中，使用这个统一的接口，为AOP切面增强的织入功能做了更多的细化和扩展。在这里我们介绍主要的几个类型：Interception around advice，Before Advice,Throws Advice,After Returning Advice,Introduction advice。</p>
<h5 id="Interception-around-advice"><a href="#Interception-around-advice" class="headerlink" title="Interception around advice"></a>Interception around advice</h5><p>这是Spring中最基本的Advice类型，它和之前笔记中的AOP动态代理类似，要实现这个advice，需要继承一个接口实现invoke方法，不过invoke方法参数不一样。具体接口如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function">Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>中间的MethodInvocation参数暴露了调用的方法，我们需要在invoke方法中通过invocation.proceed()来执行方法和得到返回值，例子如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Before: invocation=["</span> + invocation + <span class="string">"]"</span>);</div><div class="line">		Object rval = invocation.proceed();</div><div class="line">		System.out.println(<span class="string">"Invocation returned"</span>);</div><div class="line">		<span class="keyword">return</span> rval;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Before-advice"><a href="#Before-advice" class="headerlink" title="Before advice"></a>Before advice</h5><p>before advice 是一个比较简单的接口，和名字表示的一样，它在方法执行之前调用。BeforeAdvice是一个标记接口，没有任何方法，实现before advice需要继承MethodBeforeAdvice,代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">BeforeAdvice</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">(Method m, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="ThrowsAdvice，AfterAdvice"><a href="#ThrowsAdvice，AfterAdvice" class="headerlink" title="ThrowsAdvice，AfterAdvice"></a>ThrowsAdvice，AfterAdvice</h5><p>这两个advice type和before advice类似，本身是一个标记接口，但都需要实现一个对应接口，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteThrowsAdvice</span> <span class="keyword">implements</span> <span class="title">ThrowsAdvice</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(RemoteException ex)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		<span class="comment">// Do something with remote exception</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title">Advice</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method m, Object[] args, Object target)</span></span></div><div class="line">			<span class="keyword">throws</span> Throwable;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Introduction-advice"><a href="#Introduction-advice" class="headerlink" title="Introduction advice"></a>Introduction advice</h5><p>这个接口我们这里不学习，以后有兴趣在看</p>
<h3 id="二、Pointcut"><a href="#二、Pointcut" class="headerlink" title="二、Pointcut"></a>二、Pointcut</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1.概念"></a>1.概念</h4><p>Pointcut独立于Advice，它定义了Advice应该作用于哪个连接点。它筛选出需要被增强的方法的集合。同一个Pointcut匹配不同的Advice</p>
<p>Pointcut是一个AOP中一个核心接口，它筛选出增强方法的集合，也就是使advices作用于特定的类和方法。<br>具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function">ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="function">MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Pointcut分解为两个模块ClassFilter和MethodMathcer,这样做的目的是类和方法匹配模块的复用和颗粒化组合操作（比如不同的method matcher的联合使用）。</p>
<p>ClassFilter接口约束切点的目标类的集合。 matches方法返回true则表示目标类被匹配：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassFilter</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class clazz)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>MethodMathcer接口更加重要，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodMatcher</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method m, Class targetClass)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method m, Class targetClass, Object[] args)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>matches方法用来测试切点是否匹配目标类的目标方法。三个参数的matches方法只有当isRuntime()方法返回true且二参数方法返回true时才会调用。也就是说三参数matches方法只有方法是动态方法时才会调用，因为大部分的方法都是静态的，所以我们这里也只考虑二参数matches方法。</p>
<h4 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h4><p>我们这里只考虑静态切点的实现（大部分情况下够用）比如：JDKRegexpMethodPointcut,NameMatchMethodPointcut等等。对于这些切点，ClassFilter一般设置为ClassFilter.TRUE，表示匹配所有的类。而MethodMatcher则通过复写matches方法提供自己的相应实现。比如JDKRegexpMethodPointcut的matches方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String pattern,<span class="keyword">int</span> patternIndex)</span></span>&#123;</div><div class="line">    Matcher matcher=<span class="keyword">this</span>.compiledPatterns[patternIndex].matcher(pattern);</div><div class="line">    <span class="keyword">return</span> matcher.matches();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NameMatchMethodPointcut的matches方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (String mappedName : <span class="keyword">this</span>.mappedNames) &#123;</div><div class="line">			<span class="keyword">if</span> (mappedName.equals(method.getName()) || isMatch(method.getName(), mappedName)) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String methodName, String mappedName)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> PatternMatchUtils.simpleMatch(mappedName, methodName);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h3 id="三、Advisor"><a href="#三、Advisor" class="headerlink" title="三、Advisor"></a>三、Advisor</h3><h4 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1.概念"></a>1.概念</h4><p>完成对目标方法的切面增强设计（Advice）和关注点的设计（Pointcut）后，需要一个对象把他们结合起来，完成这个作用的就是Advisor（通知器）。<br>所以一个Advisor拥有一个单一的advice和一个pointcut。通过Advisor，我们将pointcut和advice结合起来，为IOC容器配置AOP提供便利</p>
<h4 id="2-实现-1"><a href="#2-实现-1" class="headerlink" title="2.实现"></a>2.实现</h4><p>一个最常用的advisor是org.springframework.aop.support.DefaultPointcutAdvisor，代码就不展示了。基本上就是拥有Pointcut和Advice，然后提供set和get方法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xl2013.github.io/2017/03/07/Spring-AOP学习笔记（二）：创建代理对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/naruto.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/07/Spring-AOP学习笔记（二）：创建代理对象/" itemprop="url">
                  Spring AOP学习笔记（二）：创建代理对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-07T20:00:22+08:00">
                2017-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在Spring中，代理对象的生成是靠配置和调用Spring的ProxyFactoryBean来实现的。所以我们这里要学习的是ProxyFactoryBean的设计结构和如何生成代理对象及如何实现方法增强</p>
<h3 id="一、类继承关系"><a href="#一、类继承关系" class="headerlink" title="一、类继承关系"></a>一、类继承关系</h3><ul>
<li>[ ] 这里需要一张类继承关系图</li>
</ul>
</blockquote>
<h3 id="二、代理对象的生成"><a href="#二、代理对象的生成" class="headerlink" title="二、代理对象的生成"></a>二、代理对象的生成</h3><ul>
<li>[ ] 这里需要一张方法调用过程图</li>
</ul>
<h4 id="1-初始化AdvisedSupport"><a href="#1-初始化AdvisedSupport" class="headerlink" title="1. 初始化AdvisedSupport"></a>1. 初始化AdvisedSupport</h4><p>ProxyfactoryBean是AdvisedSupport的子类，所以初始化它就相当于得到一个AdvisedSupport对象，就像一中介绍，AdvisedSupport对象封装了对通知器的操作。这部分工作在函数initializeAdvisorChain中完成。</p>
<p>ProxyfactoryBean中具有两个属性interceptorNames和targetName,这两个属性通过XML配置得到。XML的配置一般如下，我们通过配置类似如下的XML来使用AOP功能。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testAdvisor"</span> <span class="attr">class</span>=<span class="string">"com.abc.TestAdvisor"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testAOP"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.ProxyFactoryBean"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>com.test.AbcInterface"&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.abc.TestTarget"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>testAdvisor<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>ProxyfactoryBean通过实现BeanFactoryAware接口，从而实现了setBeanFactory()方法，同时设置一个属性来设置BeanFactory。IOC容器在对Bean初始化的时候，如果Bean是BeanFactoryAware类型的话，会调用这个bean的setBeanFactory方法，，从而bean持有IOC容器。所以我们在ProxyFactoryBean中可以看见如下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">advice=<span class="keyword">this</span>.beanFactory.geteBean(name);</div></pre></td></tr></table></figure></p>
<p>这样一来，我们通过IOC容器得到通知器实例并加入到属性advosors中，如此AdvisedSupport部分初始化完毕。</p>
<h4 id="2-通过Jdk生成动态代理对象"><a href="#2-通过Jdk生成动态代理对象" class="headerlink" title="2. 通过Jdk生成动态代理对象"></a>2. 通过Jdk生成动态代理对象</h4><p>在之前的笔记中，记录了如何使用jdk动态代理方案生成动态代理。这里也类似，最后通过Proxy类库的函数实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> Proxy.newProxyInstance(classLoader,proxyInterfaces,<span class="keyword">this</span>);</div></pre></td></tr></table></figure></p>
<p>在这里再解释一遍函数的参数的含义：</p>
<p>a. classLoader :类加载器，这里使用的是ClassUtil的defaultClassLoader<br>b. proxyInterface : 目标类实现的所有接口<br>c this : 该动态代理对象本身</p>
<p>那么如何到这一步呢？从图中我们可以看到调用流程，具体代码不再列出。这里截取关键代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">ProxyCreateSupport <span class="title">createAopProxy</span><span class="params">()</span>:</span></div><div class="line">return <span class="title">getAopProxyFactory</span><span class="params">()</span>.<span class="title">createAopProxy</span><span class="params">(<span class="keyword">this</span>)</span>.</div><div class="line"><span class="comment">//这里我们可以看到，创建AOP代理的工作交给AopProxyFactory了(默认的是DefaultAopProxyFactory)，并且传递了this///，也就是传递了AdvisedSupport。</span></div><div class="line">DefaultAopProxyFactory <span class="title">createAopProxy</span><span class="params">(AdviserdSupport config)</span>:</div><div class="line">return new <span class="title">JdkDynamicAopProxy</span><span class="params">(config)</span>;</div><div class="line"><span class="comment">//这里判断了目标类是否是接口从而选择JDK还是CGLIB，我们这里通过JDK来学习</span></div><div class="line"></div><div class="line"><span class="function">JdkDynamicAopProxy <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span>:</span></div><div class="line">return Proxy.<span class="title">newProxyInstance</span><span class="params">(classLoader,proxyInterfaces,<span class="keyword">this</span>)</span>;</div><div class="line"><span class="comment">//这样代理类生成，且AdvisedSupport对象也设置进代理类中</span></div></pre></td></tr></table></figure></p>
<p>最后我们得到了持有AdvisedSupport对象的动态代理类。</p>
<h3 id="三、拦截器调用的实现-以JdkDynamicAopProxy为例"><a href="#三、拦截器调用的实现-以JdkDynamicAopProxy为例" class="headerlink" title="三、拦截器调用的实现(以JdkDynamicAopProxy为例)"></a>三、拦截器调用的实现(以JdkDynamicAopProxy为例)</h3><h4 id="1-invoke拦截"><a href="#1-invoke拦截" class="headerlink" title="1. invoke拦截"></a>1. invoke拦截</h4><p>在代理模式笔记中我们知道，JDK动态代理对象通过invoke方法作为回调函数来实现对目标方法的拦截或者说增强。该invoke方法包含了完整的拦截器链对目标对象的拦截过程。包含获取拦截器链并对拦截器链中的拦截器进行配置，逐个运行拦截器链中的拦截增强，直到最后对目标对象的运行。</p>
<h4 id="2-拦截器链的获取"><a href="#2-拦截器链的获取" class="headerlink" title="2. 拦截器链的获取"></a>2. 拦截器链的获取</h4><p>拦截器链的获取如下代码所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorAndDynamicInterceptionAdvice(method,targetClass);</div></pre></td></tr></table></figure></p>
<p>拦截器链的是通过AdvisedSupport来获取的。</p>
<h5 id="2-1-缓存机制"><a href="#2-1-缓存机制" class="headerlink" title="2.1 缓存机制"></a>2.1 缓存机制</h5><p>拦截器获取函数代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</div><div class="line">	MethodCacheKey cacheKey = <span class="keyword">new</span> MethodCacheKey(method);</div><div class="line">	List&lt;Object&gt; cached = <span class="keyword">this</span>.methodCache.get(cacheKey);</div><div class="line">	<span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</div><div class="line">		cached = <span class="keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</div><div class="line">				<span class="keyword">this</span>, method, targetClass);</div><div class="line">		<span class="keyword">this</span>.methodCache.put(cacheKey, cached);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> cached;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在函数中，使用了内部类MethodCacheKey(为什么要封装起来？)，而且使用了缓存机制。因为invoke函数的调用是在原方法调用时回调使用，所以使用频率不低。为此在这里使用缓存机制，将提高拦截器链的获取效率。</p>
<h5 id="2-2-适配器机制"><a href="#2-2-适配器机制" class="headerlink" title="2.2 适配器机制"></a>2.2 适配器机制</h5><p>在2.1中我们可以看到拦截器链的获取由advisorChainFactory来实现。而这个advisorChainFactory是一个工厂类对象，专门用来生产拦截器链。默认的实现是DefaultAdvisorChainFactor。getInterceptorsAndDynamicInterceptionAdvice函数的重要代码我们这里截取出来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">		AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</div><div class="line"><span class="comment">//这个通知器适配器注册器对于方法的增强起关键作用,拦截器链事实上是由其加入的。</span></div><div class="line">            ....</div><div class="line">        MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</div></pre></td></tr></table></figure></p>
<p>代码中的registry是AdvisorAdapterRegistry的实现。在DefaultAdvisorAdapterRegistry中，设置了一系列的adapter适配器，正式这些适配器的实现，为Spring AOP的advice提供编织功能。它提供如下适配器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;AdvisorAdapter&gt; adapters = <span class="keyword">new</span> ArrayList&lt;AdvisorAdapter&gt;(<span class="number">3</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Create a new DefaultAdvisorAdapterRegistry, registering well-known adapters.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultAdvisorAdapterRegistry</span><span class="params">()</span> </span>&#123;</div><div class="line">	registerAdvisorAdapter(<span class="keyword">new</span> MethodBeforeAdviceAdapter());</div><div class="line">	registerAdvisorAdapter(<span class="keyword">new</span> AfterReturningAdviceAdapter());</div><div class="line">	registerAdvisorAdapter(<span class="keyword">new</span> ThrowsAdviceAdapter());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如名字所示，每个适配器对应相应的advice。比如MethodBeforeAdviceAdapter是adapter，MethodBeforeAdvice是adptee，这三个adapter共同实现接口AdvisorAdapter即target接口。很明显，这里使用了适配器模式。</p>
<p>但是不同的是这些adapter不继承adaptee，即MethodBeforeAdviceAdapter不继承MethodBeforeAdvice。因为在拦截器链中的拦截器，我们需要的不是适配器，而是封装后的拦截器。以MethodBeforeAdviceAdapter为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> (advice <span class="keyword">instanceof</span> MethodBeforeAdvice);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;</div><div class="line">		MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MethodBeforeAdviceInterceptor(advice);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它提供了两个函数，一个是用来判断advice归属的，另一个则是返回advice包装后的拦截器。这个拦截器则是实现方法增强的重要因素。以MethodBeforeAdviceInterceptor为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> MethodBeforeAdvice advice;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Create a new MethodBeforeAdviceInterceptor for the given advice.</div><div class="line">	 * <span class="doctag">@param</span> advice the MethodBeforeAdvice to wrap</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MethodBeforeAdviceInterceptor</span><span class="params">(MethodBeforeAdvice advice)</span> </span>&#123;</div><div class="line">		Assert.notNull(advice, <span class="string">"Advice must not be null"</span>);</div><div class="line">		<span class="keyword">this</span>.advice = advice;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		<span class="keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );</div><div class="line">		<span class="keyword">return</span> mi.proceed();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它封装了advice，通过invoke方法实现了方法的织入。比如methodBeforeAdvice，其增强方法before调用在目标方法之前，即mi.proceed()之前。mi.proceed()中的mi是ReflectiveMethodInvocation的实现，它通过proceed方法实现了对拦截器链的调用。我们在3中详细介绍。得到methodInterceptor后，我们回到advisorChainFactory中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</div><div class="line">				<span class="comment">// Add it conditionally.</span></div><div class="line">				PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</div><div class="line">				<span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</div><div class="line">					MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</div><div class="line">					MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</div><div class="line">					<span class="keyword">if</span> (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;</div><div class="line">						<span class="keyword">if</span> (mm.isRuntime()) &#123;</div><div class="line">							<span class="comment">// Creating a new object instance in the getInterceptors() method</span></div><div class="line">							<span class="comment">// isn't a problem as we normally cache created chains.</span></div><div class="line">							<span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</div><div class="line">								interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">else</span> &#123;</div><div class="line">							interceptorList.addAll(Arrays.asList(interceptors));</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div></pre></td></tr></table></figure></p>
<p>在得到MethodInterceptor[]后，还进行了一项工作，就是将methodInterceptor和methodmatcher组合起来。为什么要这样做呢，因为在封装advice后，就失去了advisor中的方法匹配功能，所以为了保存方法匹配功能，这里需要将methodINterceptor和methodMatcher组合起来使用，即得到InterceptorAndDynamicMethodMatcher。</p>
<p>总结：advisor-&gt;adviceAdapter-&gt;methodInterceptor-&gt;InterceptorAndDynamicMethodMatcher</p>
<h4 id="3-拦截器链的调用"><a href="#3-拦截器链的调用" class="headerlink" title="3. 拦截器链的调用"></a>3. 拦截器链的调用</h4><p>在Spring AOP中，拦截器链的调用靠类ReflectiveMethodInvocation来实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</div><div class="line"><span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></div><div class="line">retVal = invocation.proceed();</div></pre></td></tr></table></figure></p>
<p>我们可以看到，reflectiveMethodInvocation得到了代理对象，目标类，拦截器链，目标方法。有了这些，就可以实现对拦截器链的调用，具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		<span class="comment">//	We start with an index of -1 and increment early.</span></div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> invokeJoinpoint();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		Object interceptorOrInterceptionAdvice =</div><div class="line">				<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</div><div class="line">		<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</div><div class="line">			<span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></div><div class="line">			<span class="comment">// been evaluated and found to match.</span></div><div class="line">			InterceptorAndDynamicMethodMatcher dm =</div><div class="line">					(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</div><div class="line">			<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</div><div class="line">				<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="comment">// Dynamic matching failed.</span></div><div class="line">				<span class="comment">// Skip this interceptor and invoke the next in the chain.</span></div><div class="line">				<span class="keyword">return</span> proceed();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></div><div class="line">			<span class="comment">// been evaluated statically before this object was constructed.</span></div><div class="line">			<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>代码使用了递归回溯的思想，如果方法匹配拦截器，则调用封装后的invoke方法。在2中我们可以看见，invoke方法中包含的mi.proceed()就是这里的proceed(),所以不管是前置增强还是后置增强，都可以通过递归回溯实现。</p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/naruto.jpg"
               alt="Shan" />
          <p class="site-author-name" itemprop="name">Shan</p>
           
              <p class="site-description motion-element" itemprop="description">less is More</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/XL2013" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/chu-shan-61-55/" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
