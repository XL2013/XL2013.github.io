[{"title":"随笔(一)","date":"2017-11-07T07:45:03.296Z","path":"2017/11/07/随笔-一/","text":"随笔","tags":[{"name":"随笔","slug":"随笔","permalink":"https://xl2013.github.io/tags/随笔/"}]},{"title":"LogisticRegression","date":"2017-04-12T13:47:29.446Z","path":"2017/04/12/LogisticsRegression/","text":"知识准备基础数学知识sigmoid 函数(logistic function) g(x) = \\frac{1}{1+e^{-x}}对它求导可得： \\begin{align} g^{'}(x) &= \\frac{-e^{-x}}{(1+e^{-x})^2}\\\\ &= (1-\\frac{1}{1+e^{-x}})\\frac{1}{1+e^{-x}} \\\\ &= (1-g(x))g(x) \\end{align}对应的数学曲线如下： log loss function L(Y,P(Y|X)) = -logP(Y|X) 理论模型预测函数在线性回归中,预测函数为 $h_\\theta(x)=\\theta^Tx$ . 因为线性回归中的值是连续的，所以预测函数可以很好的拟合。但是在分类问题中，数据是离散的，且 $y\\in{0,1}$ ,所以不能使用之前的预测函数，而是用 $h_\\theta(x)=g(\\theta^Tx)$ 代替。 至于为什么用在sigmoid函数，因为它的范围在0,1之间，而且曲线平滑。当然，选择这个函数还有更深层次的原因，可以见后面的扩展GLM。 决策函数决策函数一般为 y = 1\\ if\\ P(y=1|x)>0.5这里的0.5是一个阈值，可以改变。 损失函数我们定义了概率函数如下，很明显是一个伯努利分布。 p(y=1|x) = g(\\theta^Tx) = \\frac{1}{1+e^{-\\theta^Tx}}因此 p(y|x) = h_\\theta(x)^y + (1-h_\\theta(x))^{1-y}假设样本独立，则可以得到似然函数如下： \\begin{align} L(\\theta) &= \\prod_{i=1}^{m}p(y^i|x^i;\\theta)\\\\ &= \\prod_{i=1}^{m}(h_\\theta(x)^y + (1-h_\\theta(x))^{1-y}) \\end{align}取对数可以得到对数似然： l(\\theta) = \\sum_{i=1}^m(ylog(h_\\theta(x)+(1-y)(1-h_\\theta(x))))回顾线性回归，我们使用最小二乘法来得到损失函数$J(\\theta)$。在这里，依旧要定义损失函数。常用的损失函数有0-1损失，log损失，hinge损失等。逻辑回归使用的是log损失函数，得到: J(\\theta) = - \\frac{1}{N}l(\\theta)所以最小化损失函数，即最大化对数似然，也就是最大似然求解： \\theta = arg \\ min\\ \\sum_{i=1}^m(ylog(h_\\theta(x))+(1-y)(1-h_\\theta(x)))参数求解求解 $\\theta$的过程和线性回归类似，常用的有gradient_descent。此外，常见的凸优化方法都可以求解该问题，比如共轭梯度下降，牛顿法，LBFGS等。这里介绍gradient_descent的解法。 \\begin{align} \\frac{\\delta}{\\delta\\theta_j}J(\\theta) &= 1/m \\frac{\\delta}{\\delta\\theta_j}\\sum_{i=1}^m(ylog(h_\\theta(x))+(1-y)(1-h_\\theta(x))) \\\\ &=1/m\\sum_{i=1}^m(\\frac{y}{h_\\theta(x)}+\\frac{y-1}{1-h_\\theta(x)})\\frac{\\delta}{\\delta\\theta_j}h_\\theta(x) \\\\ &= 1/m\\sum_{i=1}^m(\\frac{y-h_\\theta(x)}{(1-h_\\theta(x))h_\\theta(x)}) \\frac{\\delta}{\\delta\\theta_j}h_\\theta(x) \\\\ \\end{align}因为 \\begin{align} \\frac{\\delta}{\\delta\\theta_j}h_\\theta(x) &= \\frac{\\delta}{\\delta\\theta_j}g(\\theta^Tx) \\\\ &= g(\\theta^Tx)(1-g(\\theta^Tx))\\frac{\\delta}{\\delta\\theta_j}(\\theta^Tx) \\\\ &= g(\\theta^Tx)(1-g(\\theta^Tx))x_j \\\\ &= h_\\theta(x)(1-h_\\theta(x))x_j \\end{align}所以 \\frac{\\delta}{\\delta\\theta_j}J(\\theta) = 1/m\\sum_{i=1}^m(y-h_\\theta(x))x_j我们可以发现，这个结果和我们之前线性回归的结果一样。因此，这里直接使用上次的结果： \\frac{\\delta}{\\delta\\theta}J(\\theta) = 1/m(X^TX\\theta - X^Ty)所以根据gradient descent： for \\;i \\;in \\;range(niteration):\\\\ \\qquad \\theta = \\theta - \\alpha/m\\;X^T(X\\theta - y)可能会出现的疑惑为什么线性回归和逻辑回归 $\\theta$的偏导结果一致，为什么选择sigmoid函数。和线性回归中的疑惑：为什么选择最小二乘法作为损失函数一致，都可以在andrew ng的讲义中得到解释，这部分内容较为复杂，这里不再赘述。 还是提一下，损失函数选择与模型服从的分布有关，这两个模型服从的分布不一致，线性回归模型数据服从高斯分布（正态分布），逻辑回归模型数据服从伯努利分布（0-1分布），然后都用最大似然求解（对于损失函数）。而偏导一致的原因是，他们都是广义线性分布的例子。 python 代码实现和线性回归一致，这里依旧是最基础的实现，没有涉及其他优化方法和正规化。 12345678910111213141516171819202122232425262728import numpy as npimport pandas as pddef sigmoid(X): return 1 / (1 + np.exp(-X))class LogisticRegression: def __init__(self,n_iterations = 10, learning_rate=0.01): self.params = None self.n_iterations = n_iterations self.learning_rate = learning_rate def fit(self, X, y): X = np.insert(X,0,1,axis=1) n_features = np.shape(X)[1] self.params = np.random.random((n_features,)) for _ in range(self.n_iterations): y_pred = sigmoid(X.dot(self.params)) self.params += self.learning_rate * X.T.dot(y-y_pred) def predict(self,X): X = np.insert(X,0,1,axis=1) y_pred = np.round(sigmoid(X.dot(self.params))).astype(int) return y_pred 扩展 generalized model and discriminative model(生成模型和判别模型) Generalized Linear Model(广义线性模型) 参考资料 Andrew Ng 关于Linear regression和logistic Regression的讲义 一篇讲的不错的文章 wiki_logisticRegression(虽然好像没用到)","tags":[{"name":"Machine Learning algorithms","slug":"Machine-Learning-algorithms","permalink":"https://xl2013.github.io/tags/Machine-Learning-algorithms/"}]},{"title":"LinearRegression","date":"2017-04-09T08:42:01.248Z","path":"2017/04/09/LinearRegression/","text":"知识准备基础数学知识最小二乘法（least square）最小二乘法是一种数学优化技术。它通过最小化误差的平方和寻找数据的最佳函数匹配。利用最小二乘法可以简便地求得未知的数据，并使得这些求得的数据与实际数据之间误差的平方和为最小. min \\sum_{i=1}^m (y_\\theta(x)-y)^2likehood 似然（最大似然评估 ）likehood function：$L(\\theta \\mid x) = f(x \\mid \\theta)$ 在上式中，如果x已经给出，预测 $\\theta$ 的值，则该函数为似然函数。如果 $\\theta$ 已经给出，预测x的值，那么这就是普通的概率函数。 而最大似然估计就是取一定的 $\\theta$值，使得似然函数最大，即： arg \\;max \\;L(\\theta \\mid X)矩阵的迹及其部分等式定义：矩阵的迹 $tr(A) = \\sum{i=1}^m a{ii}$ 为标量且A为标量或方阵一些公式： tr(ABC) = tr(CAB) = tr(BCA)tr(A+B) = tr(A) + tr(B)\\Delta_A tr(AB) = B^T\\Delta_{A^T}f(A) = (\\Delta_Af(A))^T\\Delta_Atr(ABA^TC) = CAB+C^TAB^T\\Delta_A|A| = |A|(A^{-1})^T等式的证明见参考资料链接 矩阵求导公式矩阵A对矩阵B求导，就是矩阵A中的每个值对矩阵B中的每个值求导，向量同理。 一些重要的公式： \\frac{d X}{d X^T } = I\\frac{d X^T}{d X } = I\\frac{d AX}{d X^T } = A\\frac{d AX^T}{d X } = A\\frac{d U^TV}{d X } = \\frac{d U^T}{d X}V + \\frac{d V^T}{d X }U等式的证明见参考资料链接 基础机器学习知识 学习过程 hypothesis classification、regression loss function(error function) LinearRegression理论模型 在统计学中，线性回归是利用称为线性回归方程的最小二乘函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。 在线性回归中，数据使用线性预测函数来建模，并且未知的模型参数也是通过数据来估计。这些模型被叫做线性模型。在机器学习算法中，我们使用如下的线性函数来预测y： h_\\theta(x) = \\theta_0 + \\theta_1x_1 + \\theta_2x_2 ...即： h_\\theta(X) = \\theta^T x其中： \\theta = \\begin{bmatrix} \\theta_0\\\\ \\theta_1\\\\... \\end{bmatrix} x = \\begin{bmatrix} x_0\\\\ x_1\\\\... \\end{bmatrix}也可写成： y = Wx + b上面式子中,$\\theta$和W都是一个意思,称为参数或者权重(weight)。其中 $\\theta_0$ 和b表示偏差(bias),也可称为误差项。 之后我们统一使用$h_\\theta(X) = \\theta^Tx$ 为了评估线性模型的性能，线性回归使用最小二乘法来作为损失函数（loss function | cost function）： J(\\theta) = 1/2m\\sum_{i=1}^m (h(x^i)-y^i)^2至于为什么如此选择，后面再进行解释。 minimize J(θ)为了提升预测准确度或者时候模型性能，我们需要选择 $\\theta$ 来最小化损失函数即： \\theta = arg \\; min \\; J(\\theta)一般有两种方法求解： gradient descent为了选择 $\\theta$ 最小化 $J(\\theta)$,先给 $\\theta$一个初始值，然后重复的改变它,直到收敛得到一个 $\\theta$,使得 $J(\\theta)$ 最小。 gradient descent就是这样一个算法，从一个初始 $\\theta$开始，然后重复的执行如下更新： \\theta_j = \\theta_j - \\alpha \\frac{\\delta}{\\delta\\theta_j}J(\\theta)表达式中 $\\alpha$代表学习速率，表示 $\\theta$值收敛步长。$\\frac{\\delta}{\\delta\\theta_j}J(\\theta_j)$ 代表 $J(\\theta_j)$ 对 $\\theta$的偏导。 对于这个偏导，我们可以很容易的求解： \\begin{align} \\frac{\\delta}{\\delta\\theta_j}J(\\theta) & = \\frac{\\delta}{\\delta\\theta_j}J(\\theta) \\\\ & = \\frac{\\delta}{\\delta\\theta_j}(1/2m\\sum_{i=1}^m (h(x^i)-y^i)^2) \\\\ & = 1/m(\\sum_{i=1}^m (h(x^i)-y^i)x_j^i) \\end{align}向量化表示： \\frac{\\delta}{\\delta\\theta_j}J(\\theta) = 1/m(\\sum_{i=1}^m (h(x^i)-y^i)x_j^i) \\begin{align} \\frac{\\delta}{\\delta\\theta}J(\\theta) &= \\begin{bmatrix} \\frac{\\delta}{\\delta\\theta_1}J(\\theta) \\\\ \\frac{\\delta}{\\delta\\theta_2}J(\\theta) \\\\ ...\\\\ \\frac{\\delta}{\\delta\\theta_n}J(\\theta) \\end{bmatrix} \\\\ & = 1/m \\;\\sum_{i=1}^m \\begin{bmatrix} (h(x^i)-y^i)x_1^i \\\\ (h(x^i)-y^i)x_2^i\\\\ ...\\\\ (h(x^i)-y^i)x_n^i \\end{bmatrix} \\\\ & = 1/m\\sum_{i=1}^m((h(x^i)-y^i)x^i) \\\\ & = 1/m\\;X^T(h(X)-y) \\\\ & = 1/m\\;X^T(X\\theta - y) \\end{align}所以根据gradient descent： for \\;i \\;in \\;range(niteration):\\\\ \\qquad \\theta = \\theta - \\alpha/m\\;X^T(X\\theta - y)normal equation(least square)normal equation 其实就是解方程，使得梯度为0即达到最优值，上面我们已经求出梯度表达式： 1/m\\;X^T(X\\theta - y)令它为0可求： \\begin{align} 1/m\\;X^T(X\\theta - y) &= 0\\\\ X^TX\\theta & = X^Ty \\\\ \\theta &= (X^TX)^{-1}X^Ty \\end{align}如此一来，不需迭代，直接根据输入的X和y求得预测函数 除了上面这种解法求梯度，还有两种方法： 直接矩阵求导 \\begin{align} J(\\theta) &= 1/2m(X\\theta-y)^T(X\\theta-y) \\\\ \\frac{\\delta}{\\delta\\theta}J(\\theta) &= 1/2m(2\\frac{\\delta}{\\delta\\theta}(X\\theta-y)^T) (X\\theta-y)\\\\ & = 1/mX^T(X\\theta-y) \\end{align}利用矩阵的迹求导 J(\\theta) = 1/2m(X\\theta-y)^T(X\\theta-y)这是一个标量，所以它的迹即为它本身，所以我们可以直接用迹来求解： \\begin{align} tr J(\\theta) &= 1/2m tr(X\\theta-y)^T(X\\theta-y)\\\\ &= 1/2mtr(\\theta^TX^T-y^T)(X\\theta-y)\\\\ &= 1/2mtr(\\theta^TX^TX\\theta - y^TX\\theta-\\theta^TX^Ty-y^Ty) \\\\ => \\\\ \\frac{\\delta}{\\delta\\theta}J(\\theta) &= 1/2m\\frac{\\delta}{\\delta\\theta}tr(\\theta^TX^TX\\theta - y^TX\\theta-\\theta^TX^Ty-y^Ty) \\\\ &= 1/2m\\frac{\\delta}{\\delta\\theta}tr(\\theta^TX^TX\\theta - 2y^TX\\theta)\\\\ &= 1/2m(X^TX\\theta +X^TX\\theta -2X^Ty) \\\\ &= 1/m(X^TX\\theta - X^Ty) \\end{align}python代码实现基本numpy函数解释1234567891011121. np.insert(X,0,1,axis=1): X: numpy narray 0: 插入的位置 1：初始化的值 axis：0为row，1为col2. np.random.random((x,y)) (row,col) 随机生成值为(0,1)，大小为row*col的数组3. X.dot：矩阵乘法 X.T ： 矩阵转置 np.linalg.pinv:矩阵求伪逆 代码123456789101112131415161718192021222324252627282930313233import numpy as npclass MyLinearRegression: \"\"\" params: n_iterations: learning_rate: gradient_descent: \"\"\" def __init__(self, n_iterations=100, learning_rate=0.01, gradient_descent=True ): self.w = None self.n_iterations = n_iterations self.learning_rate = learning_rate self.gradient_descent = gradient_descent def fit(self,X,y): # X :m*n =&gt; m*(n+1) for bias weight X = np.insert(X,0,1,axis=1) # gradient descent if self.gradient_descent : n_features = np.shape(X)[1] self.w = np.random.random((n_features,)) # 注意这里col还不能填1 for _ in range(self.n_iterations): w_gradient = X.T.dot(X.dot(self.w)-y) self.w = self.w - self.learning_rate * w_gradient # normal equation else: self.w = (np.linalg.pinv(X.T.dot(X))).dot(X.T.dot(y)) def predict(self,X): X = np.insert(X,0,1,axis=1) y_pred = X.dot(self.w) return y_pred 验证：123456789101112131415161718192021222324from sklearn.model_selection import train_test_splitfrom sklearn import linear_modelfrom sklearn.metrics import mean_squared_errorfrom sklearn.tree import DecisionTreeRegressorfrom sklearn import datasetsX,y = datasets.make_regression(n_features=1,n_samples=200,bias=100,noise=5)X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.2)#clf = MyLinearRegression(gradient_descent=False)clf = MyLinearRegression(n_iterations=100)clf.fit(X_train,y_train)y_pred = clf.predict(X_test)mse = mean_squared_error(y_pred,y_test)print(mse)clf2 = linear_model.LinearRegression()clf2.fit(X_train,y_train)y_pred2 = clf2.predict(X_test)mse2 = mean_squared_error(y_pred2,y_test)print(mse2)clf3 = DecisionTreeRegressor(max_depth=20)clf3.fit(X_train,y_train)mse3 = mean_squared_error(clf3.predict(X_test),y_test)print(mse3) 可以从结果中看出，在数据集较小的情况下三个效果差不多，说明我们的算法没有问题。 扩展 why choose least squares? Locally weighted linear regression? non-parametric algorithm and parametric algorithm? 这三个问题比较上面略微复杂，直接看参考资料中Andrew Ng的讲义。 参考资料 wiki：最小二乘法 wiki：似然函数 矩阵的迹公式证明1 矩阵的迹公式证明2 矩阵求导 github 上linearRegession的实现 Andrew Ng 关于Linear regression和logistic Regression的讲义","tags":[{"name":"Machine Learning algorithms","slug":"Machine-Learning-algorithms","permalink":"https://xl2013.github.io/tags/Machine-Learning-algorithms/"}]},{"title":"算法(二)：二叉搜索树","date":"2017-03-07T12:02:31.899Z","path":"2017/03/07/算法（二）：二叉搜索树/","text":"一、性质二叉搜索树是以一颗二叉树来组织的。对任何节点x，其左子树的关键字不大于x.key，其右子树的关键字不小于x.key（二叉搜索树性质）。 二叉搜索树的基本操作和一般的二叉树类似，分为查询操作（找到x节点，x节点的前驱，后继等等），增删操作。但是二叉搜索树和一般的二叉树不同，二叉搜索树操作的耗时与二叉树的高度相关，一般为O(h)。而普通二叉树需要遍历整个树，耗时为O(n)。相比下，二叉搜索树耗时大大减少。 由于二叉搜索树性质，所以各种操作也有相应的特点。 二、查询操作 找到二叉搜索树种的x节点，这很简单，直接上代码： 123456789101112TreeNode search(TreeNode root,int val)&#123; while(root!=null&amp;&amp;root.val!=val)&#123; if(root.val&lt;val) root=root.right; else &#123; root=root.left; &#125; &#125; return root; &#125; 找到前驱： 1234567891011TreeNode successor(TreeNode node)&#123; if(node.right!=null) return minimum(node.right); TreeNode parent=node.parent; //如果node==parent.left，且node无右子树，则很明显，node的后继为其parent while(parent!=null&amp;&amp;node==parent.right)&#123; node=parent; parent=parent.parent; &#125; return parent; &#125; x节点的后继为第一个比x节点大的节点，由二叉搜索树性质，可知：如果x节点有右子树，则x节点的后继则为右子树中最小的节点。如果x节点没有右子树，因为x节点的左子树都比x节点小，所以只能往x节点的祖先去找 了。如果x节点是父节点的左子树，因为父节点的右子树节点比父节点和左子树节点都大，所以父节点必是x节点的后继。如果x节点是父节点的右子树，则只能继续往父节点的祖先去找。直到找到x节点为父节点的左子树为止。 3.前驱（类似后继）：12345678910TreeNode predecessor(TreeNode node)&#123; if(node.left!=null) return maximum(node.left); TreeNode parent=node.parent; while(parent!=null&amp;&amp;node==parent.left)&#123; node=parent; parent=parent.parent; &#125; return parent;&#125; 最小节点最大节点: 由于二叉搜索树的性质，可以很简单的找出树中的最大关键字元素和最小的关键字元素即最左或最右。 1234567891011121314151617//返回最小的关键字元素 TreeNode minimum(TreeNode root)&#123; if(root==null) return null; while(root.left!=null)&#123; root=root.left; &#125; return root; &#125; //返回最大的关键字元素 TreeNode maximum(TreeNode root)&#123; if(root==null) return null; while(root.right!=null)&#123; root=root.right; &#125; return root; &#125; 三、插入操作插入一个节点也很简单，如果当前节点比需插入的节点大，则往该节点的左子树插入，直到发现空节点。1234567891011121314151617181920212223242526//向二叉搜索树中插入元素void insert(Tree tree,TreeNode node)&#123; TreeNode temp=null; TreeNode root=tree.root; while(root!=null)&#123; if(root.val&lt;node.val)&#123; temp=root; root=root.right; &#125; else&#123; temp=root; root=root.left; &#125; &#125; node.parent=temp; if(temp==null)//树为空 tree.root=node; else if(temp.val&lt;node.val) temp.right=node; else &#123; temp.left=node; &#125;&#125; 在编写该函数时，我发现有两种解决方法，一种是遍历树，找到可插入的空节点后直接插入。另一种是遍历树，找到可插入的空节点后，保存节点信息，然后在进行插入操作。上诉代码就是第二种方法，而我第一次写的是第一种方法。仔细想了下，第二种方法其实更好，它将寻找插入节点和插入两种操作代码分隔开来，降低了代码的耦合度。而我的那种方法直接将两种操作合二为一，代码看起来既繁琐又不美观。以后要注意将不同操作解耦的思想。（先明确有多少种操作，在明确是否可以将操作分隔进行） 四、删除操作删除是二叉搜索树中比较麻烦的一种操作。在删除节点的过程中，由于该节点可能还有子节点，所以还需对树的结构进行调整。具体先分为4种情况： 该节点的右子树为空 该节点的左子树为空 该节点的左右子树都不为空 该节点的左右子树都为空 1,2两种情况都类似，直接将节点的非空子树与该节点调换即可。由于需涉及了很多子树调换操作，所以为了解耦，直接将该操作模块化(注意边界情况)：12345678910111213141516//这个是用子树v代替子树u private void transplant(Tree tree,TreeNode u,TreeNode v)&#123; //如果u是树的根 if(u.parent==null)&#123; tree.root=v; &#125; else if(u==u.parent.left)&#123; u.parent.left=v; &#125; else if(u==u.parent.right) u.parent.right=v; if(v!=null) v.parent=u.parent; &#125; 仔细思考下，第四种情况和1,2类似，直接将空子树和节点即可。所以第四种情况包含在1,2中，之后不需为之编写代码。再考虑第三种情况：该节点左右子树都不为空。如果像1,2中情况直接将子树对换的话，势必会丢失另一子树的信息，所以必须对结构进行调整。那么怎么调整呢，可以想到先摘出一个子树作为另一子树中一个节点的子树，那么就变成了1,2中的情况。摘出左右都行，这里选择摘出左子树。 假设摘出了左子树，那么该怎么选择右子树中的节点呢？其实很简单，因为右子树中的节点都比左子树大，所以摘出的左子树可直接作为右子树中节点的左子树。那么问题就变成了找出右子树中的左孩子为空的节点，而左孩子为空，则表明该节点是右子树中最小的节点。 这样做是可以保证树的二叉搜索树性质，但是可以发现，每删除一个节点，树的高度就会增大许多。这是因为直接将删除节点的左子树插入到右子树最左节点，很明显，树的高度增加了许多。为了防止这种情况，需要调整删除后的树的结构。 需要调整的情况分为两种：一是右子树的最左节点即为删除节点的右孩子，这种情况下不需调整，高度最多变化1。二是右子树的最左节点不为删除节点的右孩子，这种情况如果不调整，高度变化最大为左子树的高度，所以需要调整。这里设删除节点为x，左子树根节点（x左孩子）为l，右子树根节点为r，则右子树的最小节点为y=minimum(r);调整代码如下：12345678if(y!=r)&#123; transplant(T,y,y.right); y.right=r; r.parent=y;&#125;y.left=x.left;x.left.parent=y;transplant(T,x,y); 第二种情况下，做出这样的调整：将y和它的右子树对换，这样摘出了y节点。然后将y节点作为x节点左右子树的父节点。如此一来相当于x和y节点对换，高度最多变化1。 综上删除节点的代码如下：1234567891011121314151617181920212223242526void delete(Tree tree,TreeNode root)&#123; //case:a if(root.left==null)&#123; transplant(tree,root, root.right); &#125; //case:b else if(root.right==null)&#123; transplant(tree,root, root.left); &#125; else&#123; TreeNode minimumNode=minimum(root.right); //case :d if(minimumNode!=root.right)&#123; transplant(tree, minimumNode, minimumNode.right); minimumNode.right=root.right; root.right.parent=minimumNode; &#125; //case :c minimumNode.left=root.left; root.left.parent=minimumNode; transplant(tree, root, minimumNode); &#125;&#125; 五、总结在删除操作了解到，光保持二叉搜索树性质有时候还不够，还需要保持树的高度，保证在进行插入删除操作时，树的高度不能增长太快，毕竟二叉搜索树的操作的效率和树的高度有关（都是O(n)）。 在4中的删除操作进行了一定调整来保证树高，但是不能总是保证树的高度合理。并且在插入过程中没有做出任何措施去维护树高。为了保证树的平均高度，可以通过“随机构建二叉搜索树”即插入的过程是随机的，还可以通过创建一个新的性质的二叉搜索树-红黑树。详情见《算法：红黑树》","tags":[{"name":"算法","slug":"算法","permalink":"https://xl2013.github.io/tags/算法/"}]},{"title":"算法(一)：分治、动态规划与贪心算法","date":"2017-03-07T12:02:31.897Z","path":"2017/03/07/算法（一）：分治、动态规划与贪心算法/","text":"可能这里需要分开讲解三种算法，然后这里写他们的联系与区别以及什么时候使用。 每个算法的标识问题 分治： 归并排序 最大子数组 动态规划： 最长公共子序列 最长回文子序列 钢条切割问题 最大子数组 贪心： 活动选择问题 huffman问题 一、分治 分治就是把大的问题分解成互不相交的子问题，递归的求解子问题，然后把子问题的解组合起来 分治策略解决问题，分为三个步骤： 分解：将问题划分为子问题，子问题和原问题一样，只是规模更小 解决：步骤递归的求解子问题，如果子问题的规模够小，则停止递归，直接求解 合并：将子问题的解直接合并成原问题的解 在使用分治策略解决问题的时候，最重要的步骤就是分解问题。在划分子问题的时候，有的时候一般会出现与原问题不一样的问题，如果出现了，那么这个问题一般可以直接求解。如果这个问题不能直接求解，那么可能子问题的划分不合理，需要重新考虑。 以归并排序为例，我们需要对数组进行排序。那么原问题就是数组排序，如果我们把数组分为几部分，分别对数组进行排序，那么原问题就划分为子数组的排序问题。当子数组排序完毕，即子问题解决完毕，则进行合并，将子问题的解合并成原问题的解。伪代码如下：12345678910 void sort(arr,left,right)&#123; //子问题的规模最小，停止递归 if(left==right) return arr[left];int mid=(left+right)/2;//划分子问题，递归求解sort(arr,left,mid);sort(arr,mid+1,right);//求解完毕，合并子问题的解merge(arr,left,mid,right);&#125; 再以最大子数组为例，要得到最大连续子数组，我们可以先划分成两个子数组的最大连续子数组的问题。但是我们发现，最大连续子数组还可能出现在两个子数组之间，所以又出现了新的问题：求解包含子数组之间的最大连续数组。我们可以发现，这个问题我们可以直接求解，而不需要再次递归求解。所以原问题的划分成功，我们得到了两个和原问题一致的子问题和一个可直接求解的问题。这样，我们就可以编码解决了。 从这两个问题中，我们可以发现，分治策略是把原问题划分为规模更小的子问题。但是，我们需要注意的是，这两些子问题都是==不相交==的。同一层的子问题不涉及到另一个。那么，如果划分出的子问题之间存在==重叠==(即不同子问题拥有公共子问题)怎么办呢，如果继续使用分治策略，则会出现大量的重复计算的问题，导致耗时大幅增加。 为了解决重复计算的问题，我们把已计算的子问题的解保存起来，当需使用的 时候不需再次计算，直接使用。这样的方法，我们称为动态规划（dynamic programming）。 二、动态规划(DP) 动态规划通常用于最优解问题。 动态规划和分治类似，都需划分子问题，求解子问题，然后合并子问题的解。但是不同的是，划分出的子问题存在重叠，为了不重复计算，动态规划算法只对子问题计算一次，并且保存其值。 动态规划通常有以下四个步骤： 刻画一个最优解的结构特征（得到子问题的状态，即如何表示子问题的最优解）（分治没有具体表示） 递归的定义最优解的值（得到状态转移方程（递归求解公式）） （分治：概念表示） 计算最优解的值（自顶向下（备忘录）（递归），自底向上（通常选用））（类似分治中的归并） 利用计算出的信息构造最优解（如果只需要最优解的值，则不需要此步骤） 上溯4个步骤中，1,2是最重要的。通常，得到子问题的最优解结构和递归求解公式，该DP问题就已解决。在别的资料中，也称为“找出子问题的状态和状态转移方程”。经典的DP问题有钢铁切割问题和最长公共子序列问题等，为了和分治比较，这里继续采用最大子数组作为例子。在分析该例之前，先学习一下动态规划原理： 最优子结构动态规划的第一步就是刻画最优解结构。如果一个问题的最优解包含其子问题的最优解，那么我们就称该问题具有最优子结构。在使用动态规划方法时，我们需要使用子问题的最优解来构造原问题的最优解，所以我们需要考察最优解中使用的所有子问题。以下是发掘最优子结构性质的通用模式： 做出一次选择。做出这次选择会产生一个或或多个待解问题。 假定该选择得到最优解。 确定最优解选择后，可以确定子问题，以及如何最好的刻画子问题空间 利用“剪切-粘贴”（cut-paste）技术证明：作为构成原问题最优解的构成部分，每个子问题的解就是它本身的最优解。 在发掘最优子结构的过程中，我们就已经刻画出了最优解的特征。所以这4个步骤也是在求解最优解问题时，首先应该做的。另外一个判断是否能用dp的性质是子问题的无关性。如果两个子问题不同时占用同一资源的话，我们就称两个子问题是无关的。如果子问题之间不是无关的，那么这个问题就不能用DP来解决。 重叠子问题适合动态规划求解的最优解问题应该具备的第二个性质是子问题空间必须足够小，即问题的递归算法会反复的求解相同的问题，而不是一直生成新的子问题。如果递归算法反复求解相同的子问题，我们就称最优化问题具有“重叠子问题”的性质。与之相对应的是，适合用分治解决的问题通常在每一步都生成不同的子问题。动态规划算法通常利用重叠子问题的性质，对每个子问题求解一次，并把每次的结果存入一个表中，当再次需要这个值时直接读表即可，每次查表的时间为常数。 在了解了动态规划原理（使用动态规划的原因）后，我们再对最大子数组进行分析。首先先回顾最大子数组问题： 给定一个整数数组，数组值有正数和负数。求数组中的和最大的连续子数组。 第一步：刻画最优解的结构特征。我们先使用发掘最优子结构的四个步骤： 做出一次选择。我们先选择a[i]最为连续子数组的最后一位。 假设该选择得到最优解。我们假设f[i]为选择a[i]为最后一位后的最优解即最大和。 确定子问题，刻画子问题空间。a[i-1]在最优解中，那么f[i]=f[i-1]+a[i].如果不在，则f[i]=a[i];那么原问题产生了一个子问题 利用“剪切-粘贴”原理证明：作为构成原问题最优解的构成部分，每个子问题的解就是它本身的最优解。 假设f[i-1]不是子问题的最优解，那么存在f’[i-1]&gt;f[i-1]，因为两者都是以a[i-1]为结尾，所以f’[i-1]+a[i]&gt;f[i-1]+a[i]，所以f[i]不是最优解，与原假设矛盾。 综合上诉4步，我们确定了问题的最优子结构性质，而且同时也得到了最优解结构和递归求解公式。 第二步：递归定义最优解的值： 123f[i]= f[i-1]+a[i] f[i-1]&gt;0 = a[i] f[i-1]&lt;0 (如果f[i-1]&lt; 0,那么a[i-1]必不在f[i]的最优解中) 第三步：计算最优解的值 备忘录（自顶向下） 1234567891011f[]=-A;f[0]=a[0];int getMaxSubArr(int i,int []a)&#123; if(f[i]&gt;-A)&#123; return f[i]; &#125; if(getMaxSubArr(i-1,a)&gt;0) f[i]=a[i]+f[i-1]; else f[i]=a[i];&#125; 自底向上 1234567891011int getMaxSubArr(int[] a)&#123; int []f=new int[a.length]; f[0]=a[0]; for(int i=1;i&lt;a.length;i++)&#123; if(f[i-1]&lt;0) f[i]=a[i]; else f[i]=f[i-1]+a[i]; &#125; return max(f);&#125; 通常情况下，在每个子问题都求解的情况下，自底向下必备忘录算法快（省去了递归的开销）。但是当有的子问题不必求解的时候，备忘录方法比自底向下快，因为备忘录方法只会求解必要的子问题。 第四步：构造最优解 构造最优解通常有两种方法，一是根据解的表来构造（即根据f[i]），二是在计算最优解的值时，顺便记录。 根据f[i]: 12345678910111213141516void print(int []f)&#123; int max=0; for(int i=0;i&lt;f.length;i++)&#123; if(f[i]&gt;f[max])&#123; max=i; &#125; &#125; print(f,max);&#125;void print(int []f,int index)&#123; if(index&lt;0) return; if(f[index]&gt;0)&#123; print(f,index-1) System.out.print(f[i]+\" \"); &#125;&#125; 顺便记录： 12345678910111213141516171819202122232425int getMaxSubArr(int[] a)&#123; int []f=new int[a.length]; f[0]=a[0]; int []begin=new int[a.length]; int end=0; int sum=f[0]; for(int i=1;i&lt;a.length;i++)&#123; if(f[i-1]&lt;0)&#123; f[i]=a[i]; begin[i]=i; &#125; else f[i]=f[i-1]+a[i]; if(sum&lt;f[i])&#123; sum=f[i]; end=i; &#125; &#125; return sum;&#125;void print(int []begin,int end,int[]a)&#123; int b=begin[end]; for(int i=b;i&lt;=end;i++) System.out.print(a[i]+\",\");&#125; 两种方法都可以，一般在使用第二种的时候要多维护一个表。 总的来说，动态规划步骤中，总是要经历选择。算法本身不筛选选择，而是比较选择后的子问题的最优解从而得到原问题的最优解。动态规划算法的复杂度与子问题的个数和选择的个数成线性相关。以钢条切割为例，以跟n长的钢条，则一共有n个子问题，子问题中最大的选择个数为n，则动态规划的算法复杂度为O(n^2).以最大子数组为例，长度为n的数组，一共有n个子问题，但是只有一种选择，即最后一个数字为最优解的子数组的结尾。所以算法复杂度为O(n)。 那么，如果有一种选择可以使每次都得到最优解，算法复杂度就可以得到减少。这种选择就是“贪心”选择 三、贪心 贪心选择性质：通过做出局部最优（贪心）的选择来构造全局最优解。 贪心算法通过做出一系列选择来求出问题的最优解。在每个决策点，它做出当时看起来最佳的选择。这种启发式策略并不能保证找到最优解。但是对有些问题确实有效，比如活动选择问题。贪心算法是基于动态规划算法的，每个贪心算法背后都有一个更繁琐的动态规划算法。 贪心算法的设计过程如下： 确定问题的最优解结构（和动态规划一致） 设计一个递归算法（递归求解公式）(状态转移方程)（和动态规划一致） 证明如果我们做出一个贪心选择，则只剩一个子问题 证明贪心选择总是安全的（3,4步骤可以调换） 设计一个递归算法实现贪心策略 将递归算法改成迭代算法 从贪心算法的设计步骤我们可以看出，1,2步骤和动态规划一致，3,4是贪心算法最重要的部分。如何做出一个贪心选择，和证明这个贪心选择是安全的使我们在使用贪心算法时最重要的两个步骤。那么上诉7个步骤可以简化话如下： 将最优化问题转化为这样的形式：对其做出一次选择后只剩下一个子问题求解 证明做出贪心选择后，原问题总是存在最优解（即贪心选择包含在原问题最优解中）（安全的贪心策略） 证明做出贪心选择后剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解（即动态规划里的最优子结构性质） 以活动选择为例，我们使用上诉三个步骤创建贪心算法。 我们每次选择结束时间最早的活动a[k]，那么s[k]为在a[k]结束后的活动的集合，令A[k]为s[k]的最大兼容活动集。则做出选择后，只剩一个问题，在s[k]中求出A[k] 设a[j]是A[k]中最早结束的活动，a[m]是s[k]中最早结束的活动。令A’[k]=(A[k]-a[j])Ua[k],因为A[k]中的活动互不相交，且a[j]是A[k]中结束最早的活动，f[m]&lt;=f[j],所以A[k]=A’[k]。所以A’[k]也是s[k]的一个最大兼容活动集，且它包含a[m] 假设A[k]不是s[k]的最优解，A’[k]是s[k]的最优解。那么A’[k]+a[k]&lt;A[k]+a[k],则与原问题为最优解矛盾，所以存在最优子结构性质。 由上诉三个步骤，可以得到递归算法：12345678910int activitySelect(int[]s,int[]f,k,n)&#123; int m=k+1; while(m&lt;n&amp;&amp;s[m]&lt;f[k]) m++; if(m&lt;n) return activitySelect(s,f,m,n)+1; else return 0;&#125; 改进成迭代算法：12345678910111213int activitySelect(int[]s,int[]f)&#123; if(s.length==0) return 0; int k=0; int max=1; for(int i=1;i&lt;s.length;i++)&#123; if(s[i]&gt;f[k])&#123; max++; k=i; &#125; &#125; return max;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://xl2013.github.io/tags/算法/"}]},{"title":"java(四)：内部类","date":"2017-03-07T12:01:38.406Z","path":"2017/03/07/java（四）：内部类详解/","text":"一、内部类 一个类定义在另一个类中， 这就叫内部类内部类的对象默认持有创建它的那个封装类的一个对象的句柄 1.内部类可以隐藏实施细节如果普通的定义一个内部类，那么内部类没什么特别的地方。然而，当我们准备上溯造型到一个基础类（特别是到一个接口）的时候，内部类就开始发挥其关键作用（从用于实现的对象生成一个接口句柄具有与上溯造型至一个基础类相同的效果）。这是由于内部类随后可完全进入不可见或不可用状态——对任何人都将如此。所以我们可以非常方便地隐藏实施细节。我们得到的全部回报就是一个基础类或者接口的句柄，而且甚至有可能不知道准确的类型。就象下面这样：12345678910111213141516171819202122232425262728293031323334353637abstract class Contents &#123; abstract public int value();&#125;interface Destination &#123; String readLabel();&#125;public class Parcel3 &#123; private class PContents extends Contents &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; protected class PDestination implements Destination &#123; private String label; private PDestination(String whereTo) &#123; label = whereTo; &#125; public String readLabel() &#123; return label; &#125; &#125; public Destination dest(String s) &#123; return new PDestination(s); &#125; public Contents cont() &#123; return new PContents(); &#125;&#125;class Test &#123; public static void main(String[] args) &#123; Parcel3 p = new Parcel3(); Contents c = p.cont(); Destination d = p.dest(\"Tanzania\"); // Illegal -- can't access private class: Parcel3.PContents c = p.new PContents(); &#125;&#125; 现在，Contents和Destination代表可由客户程序员使用的接口（记住接口会将自己的所有成员都变成public属性）。为方便起见，它们置于单独一个文件里，但原始的Contents和Destination在它们自己的文件中是相互public的。 在Parcel3中，一些新东西已经加入：内部类PContents被设为private，所以除了Parcel3之外，其他任何东西都不能访问它。PDestination被设为protected，所以除了Parcel3，Parcel3包内的类（因为protected也为包赋予了访问权；也就是说，protected也是“友好的”），以及Parcel3的继承者之外，其他任何东西都不能访问PDestination。这意味着客户程序员对这些成员的认识与访问将会受到限制。 事实上，我们甚至不能下溯造型到一个private内部类（或者一个protected内部类，除非自己本身便是一个继承者），因为我们不能访问名字，就象在classTest里看到的那样。所以，利用private内部类，类设计人员可完全禁止其他人依赖类型编码，并可将具体的实施细节完全隐藏起来。除此以外，从客户程序员的角度来看，一个接口的范围没有意义的，因为他们不能访问不属于公共接口类的任何额外方法。这样一来，Java编译器也有机会生成效率更高的代码。 2.内部类拥有封装类对象的一个引用：链接到外部类迄今为止，我们见到的内部类好象仅仅是一种名字隐藏以及代码组织方案。尽管这些功能非常有用，但似乎并不特别引人注目。然而，我们还忽略了另一个重要的事实。创建自己的内部类时，那个类的对象同时拥有指向封装对象（这些对象封装或生成了内部类）的一个链接。所以它们能访问那个封装对象的成员——毋需取得任何资格。除此以外，内部类拥有对封装类所有元素的访问权限（注释②）。 下面这个例子阐示了这个问题123456789101112131415161718192021222324252627282930313233343536373839404142434445package test;interface Selector &#123; boolean end(); Object current(); void next();&#125;public class Sequence &#123; private Object[] o; private int next = 0; public Sequence(int size) &#123; o = new Object[size]; &#125; public void add(Object x) &#123; if(next &lt; o.length) &#123; o[next] = x; next++; &#125; &#125; private class SSelector implements Selector &#123; int i = 0; public boolean end() &#123; return i == o.length; &#125; public Object current() &#123; return o[i]; &#125; public void next() &#123; if(i &lt; o.length) i++; &#125; &#125; public Selector getSelector() &#123; return new SSelector(); &#125; public static void main(String[] args) &#123; Sequence s = new Sequence(10); for(int i = 0; i &lt; 10; i++) s.add(Integer.toString(i)); Selector sl = s.getSelector(); while(!sl.end()) &#123; System.out.println((String)sl.current()); sl.next(); &#125; &#125;&#125; 从上诉代码中我们可以看出，SSelector内部类可以引用外部类的成员变量Object[]o，从而实现了序列容器的迭代迭代功能。其实，翻看java源代码中的容器类，其中大部分的容器的迭代功能都是通过内部类实现iterator接口来实现的。比如ArrayList： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; /** * An optimized version of AbstractList.ListItr */ private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; @SuppressWarnings(\"unchecked\") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; 然后通过公有方法上溯造型来得到iterator,这样得到的迭代器是符合容器特性的容器，而且还隐藏了具体的实施细节，让使用者可以忽略iterator在不同容器的实现区别而统一使用定义的接口方法。1234567891011121314public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** * Returns an iterator over the elements in this list in proper sequence. * * &lt;p&gt;The returned iterator is &lt;a href=\"#fail-fast\"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @return an iterator over the elements in this list in proper sequence */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; 我们现在知道一个内部类可以访问封装类的成员。这是如何实现的呢？内部类必须拥有对封装类的特定对象的一个引用，而封装类的作用就是创建这个内部类。随后，当我们引用封装类的一个成员时，就利用那个（隐藏）的引用来选择那个成员。幸运的是，编译器会帮助我们照管所有这些细节。但我们现在也可以理解内部类的一个对象只能与封装类的一个对象联合创建。在这个创建过程中，要求对封装类对象的句柄进行初始化。若不能访问那个句柄，编译器就会报错。进行所有这些操作的时候，大多数时候都不要求程序员的任何介入。 二、方法和作用域中的内部类至此，我们已基本理解了内部类的典型用途。对那些涉及内部类的代码，通常表达的都是“单纯”的内部类，非常简单，且极易理解。然而，内部类的设计非常全面，不可避免地会遇到它们的其他大量用法——假若我们在一个方法甚至一个任意的作用域内创建内部类。有两方面的原因促使我们这样做： 正如前面展示的那样，我们准备实现某种形式的接口，使自己能创建和返回一个句柄。 要解决一个复杂的问题，并希望创建一个类，用来辅助自己的程序方案。同时不愿意把它公开。 在下面这个例子里，将修改前面的代码，以便使用： 在一个方法内定义的类 在方法的一个作用域内定义的类 一个匿名类，用于实现一个接口 一个匿名类，用于扩展拥有非默认构建器的一个类 一个匿名类，用于执行字段初始化 一个匿名类，通过实例初始化进行构建（匿名内部类不可拥有构建器） 所有这些都在innerscopes包内发生。首先，来自前述代码的通用接口会在它们自己的文件里获得定义，使它们能在所有的例子里使用：123456//: Destination.javapackage c07.innerscopes;interface Destination &#123; String readLabel();&#125; ///:~ 由于我们已认为Contents可能是一个抽象类，所以可采取下面这种更自然的形式，就象一个接口那样：123456//: Contents.javapackage c07.innerscopes;interface Contents &#123; int value();&#125; ///:~ 尽管是含有具体实施细节的一个普通类，但Wrapping也作为它所有衍生类的一个通用“接口”使用：12345678//: Wrapping.javapackage c07.innerscopes;public class Wrapping &#123; private int i; public Wrapping(int x) &#123; i = x; &#125; public int value() &#123; return i; &#125;&#125; ///:~ 在上面的代码中，我们注意到Wrapping有一个要求使用自变量的构建器，这就使情况变得更加有趣了。 第一个例子展示了如何在一个方法的作用域（而不是另一个类的作用域）中创建一个完整的类：123456789101112131415161718192021//: Parcel4.java// Nesting a class within a methodpackage c07.innerscopes;public class Parcel4 &#123; public Destination dest(String s) &#123; class PDestination implements Destination &#123; private String label; private PDestination(String whereTo) &#123; label = whereTo; &#125; public String readLabel() &#123; return label; &#125; &#125; return new PDestination(s); &#125; public static void main(String[] args) &#123; Parcel4 p = new Parcel4(); Destination d = p.dest(\"Tanzania\"); &#125;&#125; ///:~ PDestination类属于dest()的一部分，而不是Parcel4的一部分（同时注意可为相同目录内每个类内部的一个内部类使用类标识符PDestination，这样做不会发生命名的冲突）。因此，PDestination不可从dest()的外部访问。请注意在返回语句中发生的上溯造型——除了指向基础类Destination的一个句柄之外，没有任何东西超出dest()的边界之外。当然，不能由于类PDestination的名字置于dest()内部，就认为在dest()返回之后PDestination不是一个有效的对象。 下面这个例子展示了如何在任意作用域内嵌套一个内部类：1234567891011121314151617181920212223242526//: Parcel5.java// Nesting a class within a scopepackage c07.innerscopes;public class Parcel5 &#123; private void internalTracking(boolean b) &#123; if(b) &#123; class TrackingSlip &#123; private String id; TrackingSlip(String s) &#123; id = s; &#125; String getSlip() &#123; return id; &#125; &#125; TrackingSlip ts = new TrackingSlip(\"slip\"); String s = ts.getSlip(); &#125; // Can't use it here! Out of scope: //! TrackingSlip ts = new TrackingSlip(\"x\"); &#125; public void track() &#123; internalTracking(true); &#125; public static void main(String[] args) &#123; Parcel5 p = new Parcel5(); p.track(); &#125;&#125; ///:~ TrackingSlip类嵌套于一个if语句的作用域内。这并不意味着类是有条件创建的——它会随同其他所有东西得到编译。然而，在定义它的那个作用域之外，它是不可使用的。除这些以外，它看起来和一个普通类并没有什么区别。 下面这个例子看起来有些奇怪：12345678910111213141516//: Parcel6.java// A method that returns an anonymous inner classpackage c07.innerscopes;public class Parcel6 &#123; public Contents cont() &#123; return new Contents() &#123; private int i = 11; public int value() &#123; return i; &#125; &#125;; // Semicolon required in this case &#125; public static void main(String[] args) &#123; Parcel6 p = new Parcel6(); Contents c = p.cont(); &#125;&#125; ///:~ cont()方法同时合并了返回值的创建代码，以及用于表示那个返回值的类。除此以外，这个类是匿名的——它没有名字。而且看起来似乎更让人摸不着头脑的是，我们准备创建一个Contents对象： return new Contents()但在这之后，在遇到分号之前，我们又说：“等一等，让我先在一个类定义里再耍一下花招”：1234return new Contents() &#123;private int i = 11;public int value() &#123; return i; &#125;&#125;; 这种奇怪的语法要表达的意思是：“创建从Contents衍生出来的匿名类的一个对象”。由new表达式返回的句柄会自动上溯造型成一个Contents句柄。匿名内部类的语法其实要表达的是：12345class MyContents extends Contents &#123;private int i = 11;public int value() &#123; return i; &#125;&#125;return new MyContents(); 在匿名内部类中，Contents是用一个默认构建器创建的。下面这段代码展示了基础类需要含有自变量的一个构建器时做的事情：12345678910111213141516171819//: Parcel7.java// An anonymous inner class that calls the// base-class constructorpackage c07.innerscopes;public class Parcel7 &#123; public Wrapping wrap(int x) &#123; // Base constructor call: return new Wrapping(x) &#123; public int value() &#123; return super.value() * 47; &#125; &#125;; // Semicolon required &#125; public static void main(String[] args) &#123; Parcel7 p = new Parcel7(); Wrapping w = p.wrap(10); &#125;&#125; ///:~ 也就是说，我们将适当的自变量简单地传递给基础类构建器，在这儿表现为在“new Wrapping(x)”中传递x。匿名类不能拥有一个构建器，这和在调用super()时的常规做法不同。 在前述的两个例子中，分号并不标志着类主体的结束（和C++不同）。相反，它标志着用于包含匿名类的那个表达式的结束。因此，它完全等价于在其他任何地方使用分号。 若想对匿名内部类的一个对象进行某种形式的初始化，此时会出现什么情况呢？由于它是匿名的，没有名字赋给构建器，所以我们不能拥有一个构建器。然而，我们可在定义自己的字段时进行初始化：1234567891011121314151617181920//: Parcel8.java// An anonymous inner class that performs// initialization. A briefer version// of Parcel5.java.package c07.innerscopes;public class Parcel8 &#123; // Argument must be final to use inside // anonymous inner class: public Destination dest(final String dest) &#123; return new Destination() &#123; private String label = dest; public String readLabel() &#123; return label; &#125; &#125;; &#125; public static void main(String[] args) &#123; Parcel8 p = new Parcel8(); Destination d = p.dest(\"Tanzania\"); &#125;&#125; ///:~ 若试图定义一个匿名内部类，并想使用在匿名内部类外部定义的一个对象，则编译器要求外部对象为final属性。这正是我们将dest()的自变量设为final的原因。如果忘记这样做，就会得到一条编译期出错提示。 只要自己只是想分配一个字段，上述方法就肯定可行。但假如需要采取一些类似于构建器的行动，又应怎样操作呢？通过Java 1.1的实例初始化，我们可以有效地为一个匿名内部类创建一个构建器：12345678910111213141516171819202122232425//: Parcel9.java// Using \"instance initialization\" to perform// construction on an anonymous inner classpackage c07.innerscopes;public class Parcel9 &#123; public Destination dest(final String dest, final float price) &#123; return new Destination() &#123; private int cost; // Instance initialization for each object: &#123; cost = Math.round(price); if(cost &gt; 100) System.out.println(\"Over budget!\"); &#125; private String label = dest; public String readLabel() &#123; return label; &#125; &#125;; &#125; public static void main(String[] args) &#123; Parcel9 p = new Parcel9(); Destination d = p.dest(\"Tanzania\", 101.395F); &#125;&#125; ///:~ 在实例初始化模块中，我们可看到代码不能作为类初始化模块（即if语句）的一部分执行。所以实际上，一个实例初始化模块就是一个匿名内部类的构建器。当然，它的功能是有限的；我们不能对实例初始化模块进行过载处理，所以只能拥有这些构建器的其中一个。 上诉就是匿名内部的使用规则及方法，实际上我们队匿名内部类的使用非常常见及广泛，比如我们经常使用的线程类0可以这样使用:12345678Thread t1=new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.print(\"t1\"); &#125; &#125;);t1.start(); 还有android中经常使用到的actionlistenner等等。 三、静态内部类为正确理解static在应用于内部类时的含义，必须记住内部类的对象默认持有创建它的那个封装类的一个对象的句柄。然而，假如我们说一个内部类是static的，这种说法却是不成立的。static内部类意味着：(1) 为创建一个static内部类的对象，我们不需要一个外部类对象。(2) 不能从static内部类的一个对象中访问一个外部类对象。但在存在一些限制：由于static成员只能位于一个类的外部级别，所以内部类不可拥有static数据或static内部类。 倘若为了创建内部类的对象而不需要创建外部类的一个对象，那么可将所有东西都设为static。为了能正常工作，同时也必须将内部类设为static。如下所示：12345678910111213141516171819202122232425262728293031323334353637//: Parcel10.java// Static inner classespackage c07.parcel10;abstract class Contents &#123; abstract public int value();&#125;interface Destination &#123; String readLabel();&#125;public class Parcel10 &#123; private static class PContents extends Contents &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; protected static class PDestination implements Destination &#123; private String label; private PDestination(String whereTo) &#123; label = whereTo; &#125; public String readLabel() &#123; return label; &#125; &#125; public static Destination dest(String s) &#123; return new PDestination(s); &#125; public static Contents cont() &#123; return new PContents(); &#125; public static void main(String[] args) &#123; Contents c = cont(); Destination d = dest(\"Tanzania\"); &#125;&#125; ///:~ 在main()中，我们不需要Parcel10的对象；相反，我们用常规的语法来选择一个static成员，以便调用将句柄返回Contents和Destination的方法。 通常，我们不在一个接口里设置任何代码，但static内部类可以成为接口的一部分。由于类是“静态”的，所以它不会违反接口的规则——static内部类只位于接口的命名空间内部：12345678910//: IInterface.java// Static inner classes inside interfacesinterface IInterface &#123; static class Inner &#123; int i, j, k; public Inner() &#123;&#125; void f() &#123;&#125; &#125;&#125; ///:~ 四、内部类的覆盖若创建一个内部类，然后从封装类继承，并重新定义内部类，那么会出现什么情况呢？也就是说，我们有可能覆盖一个内部类吗？这看起来似乎是一个非常有用的概念，但“覆盖”一个内部类——好象它是外部类的另一个方法——这一概念实际不能做任何事情：123456789101112131415161718192021222324252627//: BigEgg.java// An inner class cannot be overriden// like a methodclass Egg &#123; protected class Yolk &#123; public Yolk() &#123; System.out.println(\"Egg.Yolk()\"); &#125; &#125; private Yolk y; public Egg() &#123; System.out.println(\"New Egg()\"); y = new Yolk(); &#125;&#125;public class BigEgg extends Egg &#123; public class Yolk &#123; public Yolk() &#123; System.out.println(\"BigEgg.Yolk()\"); &#125; &#125; public static void main(String[] args) &#123; new BigEgg(); &#125;&#125; ///:~ 默认构建器是由编译器自动合成的，而且会调用基础类的默认构建器。大家或许会认为由于准备创建一个BigEgg，所以会使用Yolk的“被覆盖”版本。但实际情况并非如此。输出如下：12New Egg()Egg.Yolk() 这个例子简单地揭示出当我们从外部类继承的时候，没有任何额外的内部类继续下去。然而，仍然有可能“明确”地从内部类继承：1234567891011121314151617181920212223242526272829303132333435//: BigEgg2.java// Proper inheritance of an inner classclass Egg2 &#123; protected class Yolk &#123; public Yolk() &#123; System.out.println(\"Egg2.Yolk()\"); &#125; public void f() &#123; System.out.println(\"Egg2.Yolk.f()\"); &#125; &#125; private Yolk y = new Yolk(); public Egg2() &#123; System.out.println(\"New Egg2()\"); &#125; public void insertYolk(Yolk yy) &#123; y = yy; &#125; public void g() &#123; y.f(); &#125;&#125;public class BigEgg2 extends Egg2 &#123; public class Yolk extends Egg2.Yolk &#123; public Yolk() &#123; System.out.println(\"BigEgg2.Yolk()\"); &#125; public void f() &#123; System.out.println(\"BigEgg2.Yolk.f()\"); &#125; &#125; public BigEgg2() &#123; insertYolk(new Yolk()); &#125; public static void main(String[] args) &#123; Egg2 e2 = new BigEgg2(); e2.g(); &#125;&#125; ///:~ 现在，BigEgg2.Yolk明确地扩展了Egg2.Yolk，而且覆盖了它的方法。方法insertYolk()允许BigEgg2将它自己的某个Yolk对象上溯造型至Egg2的y句柄。所以当g()调用y.f()的时候，就会使用f()被覆盖版本。输出结果如下：12345Egg2.Yolk()New Egg2()Egg2.Yolk()BigEgg2.Yolk()BigEgg2.Yolk.f() 对Egg2.Yolk()的第二个调用是BigEgg2.Yolk构建器的基础类构建器调用。调用g()的时候，可发现使用的是f()的被覆盖版本。 五、内部类的标识符由于每个类都会生成一个.class文件，用于容纳与如何创建这个类型的对象有关的所有信息（这种信息产生了一个名为Class对象的元类），所以大家或许会猜到内部类也必须生成相应的.class文件，用来容纳与它们的Class对象有关的信息。这些文件或类的名字遵守一种严格的形式：先是封装类的名字，再跟随一个$，再跟随内部类的名字。例如，由InheritInner.java创建的.class文件包括：123InheritInner.classWithInner$Inner.classWithInner.class 如果内部类是匿名的，那么编译器会简单地生成数字，把它们作为内部类标识符使用。若内部类嵌套于其他内部类中，则它们的名字简单地追加在一个$以及外部类标识符的后面。 这种生成内部名称的方法除了非常简单和直观以外，也非常“健壮”，可适应大多数场合的要求（注释③）。由于它是Java的标准命名机制，所以产生的文件会自动具备“与平台无关”的能力（注意Java编译器会根据情况改变内部类，使其在不同的平台中能正常工作）","tags":[{"name":"java","slug":"java","permalink":"https://xl2013.github.io/tags/java/"}]},{"title":"java（三）：构造器与多态性（多形性）","date":"2017-03-07T12:01:38.387Z","path":"2017/03/07/java（三）：构造器与多态性（多形性）/","text":"一、多态 多态：多种类型当做同一种类型对待。将发生改变的东西同没有发生改变的东西区分开 1.方法调用绑定方法绑定，将一个方法调用同一个方法主体连接到一起就被称为“绑定”(binding)。如果在程序运行前执行绑定，就叫做“早期绑定”。c编译器只有早期绑定一种方法调用。在运行期进行，以对象为基础的方法绑定称为“后期绑定”，也可称为“动态绑定”。java中的所有方法都采用动态绑定，除非方法声明为final。 动态绑定的例子很常见，在笔记“上溯造型与下溯造型”中，可以看到具体的代码例子，这里不再赘述。java虚拟机怎么实现动态绑定的，可以见笔记java虚拟机学习中的多态篇。 2.覆盖与重载（过载）重载：方法名一样，但是参数不同的方法，指同一样东西在不同地方具有多种含义。覆盖：子类继承父类的方法，参数、名字、返回值都相同，但是具体实现不同，指只具有一种含义但是原先的含义被后来者替代。例： 12345678910111213141516171819202122232425262728293031323334package thinkInJava;class Shape&#123; public void draw()&#123; System.out.println(\"Shape\"); &#125;&#125;class Triangle extends Shape&#123; public void draw()&#123; System.out.println(\"Triangle\"); &#125;&#125;class Rectangle extends Shape&#123; public void draw()&#123; System.out.println(\"Rectangle\"); &#125; public void draw(String val)&#123; System.out.println(val+\": Rectangle\"); &#125;&#125;public class Override &#123; public static void draw(Shape shape)&#123; shape.draw(); &#125; public static void main(String args[])&#123; Triangle triangle=new Triangle(); Rectangle rectangle=new Rectangle(); Override.draw(triangle); Override.draw(rectangle); rectangle.draw(\"overload\"); &#125;&#125; 可以看到，在Shape的子类中draw方法被覆盖，在Triangle子类中，draw方法也被重载。编译器对被覆盖的draw方法的调用都是通过动态绑定的，所以可以正确的执行相应对象的函数。java通过方法覆盖实现多态，而重载与多态无关。 二、构造器与多态由于衍生类继承基类，所以能访问基础类的任何public和protected成员，这意味着当我们使用衍生类成员时，必须假定基础类的所有成员都是有效的。为达到这个要求，则在对象的构造器调用之前，先调用基础类的构造器，以保证基础类的成员先被初始化。初始化的过程如下： (1) 在采取其他任何操作之前，为对象分配的存储空间初始化成二进制0； (2) 调用基类构造器 (3) 按声明顺序调用成员初始化代码 (4) 调用衍生类构造器主体 下面这个例子很好的体现了初始化过程：12345678910111213141516171819202122232425package thinkInJava;abstract class Monster&#123; public Monster() &#123; // TODO Auto-generated constructor stub System.out.println(getHP()); &#125; abstract int getHP();&#125;class Boss extends Monster&#123; int HP=1; public Boss()&#123; HP=5; &#125; int getHP()&#123; return HP; &#125;&#125;public class InitOrder &#123; public static void main(String args[])&#123; Boss boss=new Boss(); System.out.println(boss.getHP()); &#125;&#125;输出：0 1 5 可以看到为对象分配空间，并初始化为0。然后调用基础类的构造器，在这里根据多态，调用的getHP为子类Boss的getHP。因为子类的成员初始化还没执行且被初始为0，所以返回的是0。之后执行的是成员初始化代码，所以HP的值被初始化为1.然后调用的是衍生类的构造器，打印1，而且HP被赋值为5。如此一来，对象的构造完成。接下来执行对象的方法，打印的就是赋值后的HP5了。 注意，在调用构造器之前先执行的是成员初始化代码。 三、扩展:通过继承来设计这里就直接copy thinkInJava 中的内容，因为这部分对我们如何设计对象还是有帮助的。 学习了多形性的知识后，由于多形性是如此“聪明”的一种工具，所以看起来似乎所有东西都应该继承。但假如过度使用继承技术，也会使自己的设计变得不必要地复杂起来。事实上，当我们以一个现成类为基础建立一个新类时，如首先选择继承，会使情况变得异常复杂。 一个更好的思路是首先选择“合成” —— 如果不能十分确定自己应使用哪一个。合成不会强迫我们的程序设计进入继承的分级结构中。同时，合成显得更加灵活，因为可以动态选择一种类型（以及行为），而继承要求在编译期间准确地知道一种类型。下面这个例子对此进行了阐释：1234567891011121314151617181920212223242526272829//: Transmogrify.java// Dynamically changing the behavior of// an object via composition.interface Actor &#123;void act();&#125;class HappyActor implements Actor &#123;public void act() &#123;System.out.println(\"HappyActor\");&#125;&#125;class SadActor implements Actor &#123;public void act() &#123;System.out.println(\"SadActor\");&#125;&#125;class Stage &#123;Actor a = new HappyActor();void change() &#123; a = new SadActor(); &#125;void go() &#123; a.act(); &#125;&#125;public class Transmogrify &#123;public static void main(String[] args) &#123;Stage s = new Stage();s.go(); // Prints \"HappyActor\"s.change();s.go(); // Prints \"SadActor\"&#125;&#125; 在这里，一个 Stage 对象包含了指向一个 Actor 的句柄，后者被初始化成一个 HappyActor 对象。这意味着go()会产生特定的行为。但由于句柄在运行期间可以重新与一个不同的对象绑定或结合起来，所以SadActor对象的句柄可在 a 中得到替换，然后由 go()产生的行为发生改变。这样一来，我们在运行期间就获得了很大的灵活性。与此相反，我们不能在运行期间换用不同的形式来进行继承；它要求在编译期间完全决定下来。一条常规的设计准则是：用继承表达行为间的差异，并用成员变量表达状态的变化。在上述例子中，两者都得到了应用：继承了两个不同的类，用于表达 act()方法的差异；而 Stage 通过合成技术允许它自己的状态发生变化。在这种情况下，那种状态的改变同时也产生了行为的变化。","tags":[{"name":"java","slug":"java","permalink":"https://xl2013.github.io/tags/java/"}]},{"title":"java（一）：上溯造型与下溯造型","date":"2017-03-07T12:01:38.378Z","path":"2017/03/07/java（一）：上溯造型与下溯造型/","text":"一、上溯造型 上溯造型：把衍生类型当做它的基本类型处理 我们在学习面向对象的时候都已经习惯将子类当做父类类型去处理。在面向对象的概念中，这过程叫做上溯造型。在C++和Java中，上溯造型有点不同。在java中，一个类型还可以上溯造型到它实现的接口。在初学java的时候，没懂这一点导致很多代码看不懂。所以，接下来将有一个代码示例来展示上溯造型到父类和实现的接口的过程：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package thinkInJava;import java.util.ArrayList;class Human&#123; public void printHuman()&#123; System.out.println(\"Human\"); &#125;&#125;interface Eat&#123; void eatFruit();&#125;interface Sleep&#123; void sleepInBed();&#125;class Man extends Human&#123; public void printMan()&#123; System.out.print(\"man\"); &#125;&#125;class Son extends Man implements Eat,Sleep&#123; @Override public void sleepInBed() &#123; // TODO Auto-generated method stub System.out.println(\"son.sleepInBed\"); &#125; @Override public void eatFruit() &#123; // TODO Auto-generated method stub System.out.println(\"son.eatFruit\"); &#125;&#125;public class Upcasting &#123; public static void useMan(Man man)&#123; man.printMan(); &#125; public static void useHuman(Human human)&#123; human.printHuman(); &#125; public static void main(String args[])&#123; ArrayList&lt;Eat&gt; eats=new ArrayList&lt;Eat&gt;(); ArrayList&lt;Sleep&gt; sleeps=new ArrayList&lt;Sleep&gt;(); Son son1=new Son(); Son son2=new Son(); eats.add(son1); eats.add(son2); sleeps.add(son2); sleeps.add(son1); for(Eat eat : eats)&#123; eat.eatFruit(); &#125; for(Sleep sleep :sleeps)&#123; sleep.sleepInBed(); &#125; useHuman(son1); useMan(son2); &#125;&#125; 在代码中我们可以看到，Son类继承了Man和Human，实现了接口Eat和Sleep。在使用中，我们既可以将son对象当做Eat接口、Sleep接口使用，也可以当做父类和祖父类使用。 上溯造型 是安全的类型转换，在代码中以eats为例，我们将son1和son2加入到eats中，这时son将只剩eat的方法可以使用，本身的其他方法不可见，这样即保证了类型转换的安全。另外，在useMan（）中，我们并不能确定传递进的参数为Man，所以涉及到新的问题：运行时类型判定，这点我们下次再学习。 二、下溯造型 下溯造型： 相比于上溯造型，下溯造型未必是安全的。当一个父类对象想下溯造型至子类对象时，就会报java.lang.ClassCastException。例：12Man man=new Man();Son son=(Son)man; 我们什么时候会用到下溯造型呢，比如在useMan()中，我们函数参数是man，但是我们可能传递的是son对象，这时我们如果需要使用son的函数，就需要把man下溯造型至son。因为如前面所言，上溯造型时，本身的方法不可见，如需使用本身的方法，必须下溯造型至本身。在使用下溯造型时，我们一般要加一个保障措施，就是先判断对象是否是所需下溯造型类的实例。即：1234if(man instanceof Son)&#123; Son son=(Son)man; son.printSon();&#125; 另外，对于父类，本身，实现的接口，instanceof返回都是true。所以如果需要判断对象是哪个类的直接实例，需从最下级开始使用instanceof判断，第一个返回true的即是其直接实例。","tags":[{"name":"java","slug":"java","permalink":"https://xl2013.github.io/tags/java/"}]},{"title":"java（二）：运行期类型检查与反射","date":"2017-03-07T12:01:38.376Z","path":"2017/03/07/java（二）：运行期类型检查与反射/","text":"一、运行类型检查 RTTI(Run Time Type Indetify):运行时类型鉴定：当只有一个基础类句柄时，判断对象的正确类型 迄今为止，我们已知的RTTI形式包括：(一)、 经典造型，如（Shape），它用来保证造型的正确性，并在遇到失败造型时，报出 ClassCastException违例(二)、 代表对象类型的Class对象。可查询Class对象，获取有用的运行期资料。 对于这两种RTTI形式，第一种是我们不需要考虑，是由编译器去实现。第二种，java中采取“反射”的技术，通过得到Class对象来回去类的所有信息，从而可以判断类型。 二、反射： 运行期类信息我们可以通过代码获取Class对象，如果已有对象，则可以通过getclass得到class对象。如果没有对象，则通过ClassForName来得到class对象。示例如下： 1234567891011package thinkInJava;public class Reflection &#123; public static void main(String args[]) throws ClassNotFoundException&#123; String name=\"paperfan\"; Class cls1=name.getClass(); Class cls2=Class.forName(\"java.lang.String\"); System.out.println(\"cls1:\"+cls1.getName()); System.out.println(\"cls2:\"+cls2.getName()); &#125;&#125; 得到class对象后，我们可以得到的信息就非常多了，比如有函数getSuperclass()，可以得到父类。通过getINterfaces()，可以得到所有实现的接口。通过newInstance(),我们可以直接得到类的实例，一旦创建实例，就可以得到object句柄，但是这个句柄指向的是类对应的对象示例。所以，利用反射技术我们可以得到一个对象的所有信息。","tags":[{"name":"java","slug":"java","permalink":"https://xl2013.github.io/tags/java/"}]},{"title":"算法(三)：红黑树","date":"2017-03-07T00:59:57.645Z","path":"2017/03/07/算法（三）：红黑树/","text":"一、红黑树是什么？之前了解到，二叉搜索树可以以O(h)的复杂度来执行查询插入删除等操作。但是由于数据插入顺序的不同，高度往往不同，甚至如果按从小到大或者从大到小顺序插入，高度则为n，效率并没有得到提升。所以为了保证高度稳定，提出了特殊的二叉树：红黑树。 红黑树是一颗具有红黑性质的二叉搜索树。它给节点增加了一个存储位来表示颜色，可以是RED或BLACK，通过对任何一条从根到叶节点的简单路径上节点颜色的限制 ，红黑树确保了没有一条路径会比另一条长两倍，因而近似平衡。 红黑树的红黑性质有5点： 节点必须是红色或者黑色 根节点必须是黑色 叶子节点都是黑色即null节点的颜色默认为黑色 红色节点的孩子必须是黑色 对于每个节点，从该节点到其后代的所有叶节点，均包含相同的黑色节点 通过这5点红黑性质，红黑树的高度也就得到了限制，下面对红黑树高度得到限制进行证明。 二、红黑树高度限制的证明(操作算法复杂度为O(lg(n))的证明)首先了解一个概念：黑高（BH）。黑高是指从某个节点出发x（不包含节点）到达一个叶节点的任意一条节点路径上的黑色节点的个数，记为BH(x)。 有了这个概念后，先证明一个性质：以任一节点x为根的子树至少包含2^(bh(x)) - 1 个节点。 用归纳法证明该定理： 当x为叶子节点时，黑高为0=2^(0) -1 ,定理成立。 当x不为根节点时，则x的孩子节点的黑高为bh(x)或者bh(x)-1，假设x孩子节点的子树满足定理，则每个孩子子树至少包含2^(bh(x)-1) -1 个节点，则包含x节点的子树的节点数至少为2*(2^(bh(x)-1)-1)+1=2^(bh(x))-1。则包含x节点的子树叶满足定理 综1、2,得证。 再根据性质4，一条路径上至少有一半为黑色节点，则黑高至少为树高h的一半：h/2。于是有： 12345n&gt;=2^(h/2)-1 =&gt;lg(n+1)&gt;=h/2 =&gt;h&lt;=2lg(n+1) 从不等式中可以看出，红黑树的高度得到了限制，于是红黑树操作的算法复杂度O(h)=O(2lg(n+1))=O(lg(n)) 三、红黑树的基本操作：旋转旋转操作是红黑树中必不可少的操作，通过旋转，可以在不改变二叉树性质的情况下通过改变节点颜色来维护红黑树的性质。 [ ] 这里加个旋转示意图 根据示意图，可以发现，旋转实际上就是指针的改变，其余性质没有改变，而且左旋和右旋是相互对称的。所以可以写出如下旋转代码：12345678910111213141516171819202122232425262728293031323334353637383940private void leftRotate(RBTNode x)&#123; if(x==null||x.right==null) return; RBTNode y=x.right; x.right=y.left; if(y.left!=null)&#123; y.left.parent=x; &#125; y.left=x; y.parent=x.parent; if(y.parent==null) rootNode=y; else if(x==x.parent.left)&#123; x.parent.left=y; &#125; else &#123; x.parent.right=y; &#125; x.parent = y;&#125;private void rightRotate(RBTNode x)&#123; if(x==null||x.left==null) return; RBTNode y=x.left; x.left=y.right; if(y.right!=null)&#123; y.right.parent=x; &#125; y.right=x; y.parent=x.parent; if(y.parent==null) rootNode=y; else if(x==x.parent.left)&#123; x.parent.left=y; &#125; else &#123; x.parent.right=y; &#125; x.parent = y;&#125; 事实上，旋转代码的逻辑很简单，就是指针的互换。但是，在写起来的过程中，容易会忘记parent的设置，以及边界条件。孩子指针会记得设置，但是设置完孩子指针后，孩子节点还要指向新的父节点。其中一共改变的是三个节点的位置，所以一共需要设置三次parent，改变三次孩子节点，这里需要注意一下。 四、插入对于红黑树的插入而言，它与二叉搜索树的插入大致一致。不同的是，插入的节点首先需要配色，然后插入并配色后的树可能会违反红黑树性质，这个时候就需要fixup红黑树以保持红黑性质。 插入节点的代码和步骤和二叉搜索树的一致，这里不再赘述。首先要考虑的是，插入的节点该配什么颜色。如果插入的节点配成黑色，则很明显违背了性质5。插入节点的所有祖先节点都违背了性质5。如果不对插入节点的颜色进行改变，则它所有祖先节点的黑高都+1，而且另一支子树都比拥有该节点的子树的黑高少一。要进行修正只能对每一支子树进行加一黑高操作，这样一来又可能引起其他性质的改变，导致修正复杂度增高。而把插入节点设置成红色，则性质5不会被改变，改变的只有性质4或者性质4，这样修正起来较为简单，所以插入的节点选择涂成红色。 插入红色节点可能违背性质2，4，如果插入的节点为根节点，则违背了性质2。如果插入节点的父节点为红色，则违背了性质4。先把修正代码贴出：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void fixAfterInsert(RBTNode x)&#123; x.color=RED; while(x!=rootNode&amp;&amp;x.parent.color==RED)&#123; RBTNode p = x.parent.parent; if(x.parent == p.left)&#123; RBTNode w = p.right; /** * case1：叔节点为红色 * 因为空节点的颜色为黑色，所以不能直接使用color属性，这里使用getcolor函数 */ if(getColor(w)==RED)&#123; setColor(w, BLACK); setColor(x.parent, BLACK); setColor(p, RED); x=p; &#125; else&#123; //case2: x为红色父节点的右孩子 if(x==x.parent.right)&#123; x=x.parent; leftRotate(x); &#125; //case3: x为红色父节点的左孩子 setColor(p, RED); setColor(x.parent, BLACK); rightRotate(p); &#125; &#125; //左右对称 else&#123; RBTNode w = p.left; if(getColor(w)==RED)&#123; setColor(w, BLACK); setColor(x.parent, BLACK); setColor(p, RED); x=p; &#125; else&#123; if(x == x.parent.left)&#123; x = x.parent; rightRotate(x); &#125; setColor(p, RED); setColor(x.parent, BLACK); leftRotate(p); &#125; &#125; &#125; rootNode.color=BLACK; &#125; 首先先考虑什么时候修正完毕。当插入节点为根节点的时候，直接将颜色设为黑色即修正完毕；当插入节点被修正成黑色时，修正完毕。所以这里的循环条件为x!=rootNode&amp;&amp;x.parent.color==RED。 在考虑下在节点处于什么情况时，能够通过旋转和着色来修正。当插入一个红色节点x，且x.parent父节点为红色时，该子树多了一个红色节点。如果直接把x.parent涂成黑色，则会违背性质5（事实上，所有的操作都是为了保持性质5）。既然涂色不能解决，那么就想到通过旋转来解决。旋转点很明显是x.parent.parent，而且该节点必不为空。由于二叉树的对称性，直接假设x.parent=x.parent.parent.left。 首先，先判断是左旋还是右旋。这里在草稿纸上画出示意图，可以看出，如果围绕x.parent.parent左旋的话，问题得不到解决，因为没有涉及到x和x.parent。所以只能选择右旋， 再判断右旋前节点的颜色和x与x.parent的位置要求。(x.parent.parent颜色为黑色) 如果x为x.parent的右子节点，那么右旋时，x将成为x.parent.parent的左节点。由于性质5的要求，x.parent的颜色必须涂为黑色，同时x.parent.parent的颜色必须涂为红色（否则右支黑色节点+1）。这时，又出现两个红色节点相连，问题没有得到解决。 如果x为x.parent的左节点，那么右旋时x.parent涂为黑色，x.parent.parent涂为红色，x还在左支。这时黑高不变，但是如果x.parent.parent.left的颜色为红色，则又出现了两个红色节点相连问题。如果为黑色的话，可以看出性质4页没有违背，这时x.parent.color也为黑色，修正完毕，推出循环。 综1、2，可以通过旋转着色解决的情况是：x=x.parent.left;x.parent.parent.color=BLACK;把这种情况称为目的情况。其他情况则需要通过旋转和着色转换成目的情况，然后在目的情况修正。具体其他情况算法导论和其他博客有大量讲解，这里就不再赘述。至于如何转换，可以像上诉的1、2进行假设和尝试来获得转换方法。 五、删除红黑树的删除操作是在二叉搜索树的删除操作基础上做出些许改变得到的。它通过维护需要删除的节点，和代替删除节点位置的节点来进行fix操作。先看具体代码：123456789101112131415161718192021222324252627282930313233343536/** * 由于和算法导论中不同，没有哨兵节点，所以实现也有不同，这里采用java库中的TreeMap中的写法 * @param y */ public void delete(RBTNode p)&#123; if(p.left != null &amp;&amp; p.right != null )&#123; RBTNode s = minimum(p.right); p.val = s.val; p=s; &#125; RBTNode replacement = p.left != null ? p.left : p.right; if(replacement != null)&#123; transplant(p, replacement); if(p.color == BLACK)&#123; fixAfterDelete(replacement); &#125; &#125;else if (p.parent==null) &#123; rootNode = null; &#125;else&#123; /** * 如果没有子节点的话，就使用本身作为虚拟节点来参与fix过程，之后unlink就行 * 在算法导论中所有的null节点都由哨兵节点代替，这里没有哨兵节点，所以直接使用本身 */ if(p.color == BLACK) fixAfterDelete(p); //unlink p if(p == p.parent.left)&#123; p.parent.left = null; &#125;else &#123; p.parent.right = null; &#125; p.parent = null; &#125; &#125; 首先要做的就是找到删除的节点和代替的节点。和二叉搜索树一致，分为下列几种情况： 删除节点有右孩子和左孩子。通过找到删除节点的后继，并且将删除节点的值设为后继的值。如此一来，就相当于删除节点为后继节点，代替节点为后继节点的右孩子。具体操作如代码所示 删除节点有单一子节点，删除节点不变，删除节点为单一子节点 删除节点没有孩子，那么没有代替节点。由于在代码中没有算法导论中的哨兵节点，先不删除节点，反用它作为代替节点，即用本身代替本身。在修正后再删除该节点。 找到删除节点和代替节点后，需要进行判断是否需要fix。如果删除节点的颜色为红色，那么删除后黑高不变，而且也不会违反性质4(删除节点的父节点必为黑色)，所以无需fix。如果删除节点为黑色，由于子树少了一个黑色节点，违背了性质5，而且可能代替节点和删除节点的父节点都为红色，违背性质4。 找到fix条件后，开始通过代替节点进行fixAfterDeletion。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 //对颜色的处理都使用getColor和setColor，因为空节点为黑色。如果直接使用x.color，则会出空指针错误 //实际上，在java的TreeMap中，对left和right、parent都用函数代替。这里为了简便，没采用。private void fixAfterDelete(RBTNode x)&#123; while(x != rootNode &amp;&amp; getColor(x) != RED)&#123; if(x == x.parent.left)&#123; RBTNode w = x.parent.right; if(getColor(w) == RED)&#123; setColor(w, BLACK); setColor(x.parent, RED); leftRotate(x.parent); w = x.parent.right; &#125; if(getColor(w.left)==BLACK &amp;&amp; getColor(w.right)== BLACK)&#123; setColor(w, RED); x = x.parent; &#125;else &#123; if(getColor(w.left) == RED &amp;&amp; getColor(w.right) == BLACK)&#123; setColor(w.left, BLACK); setColor(w, RED); rightRotate(w); w = x.parent.right; &#125; setColor(w, x.parent.color); setColor(x.parent, BLACK); setColor(w.right, BLACK); leftRotate(x.parent); x=rootNode; &#125; &#125;//对称 else&#123; RBTNode w = x.parent.left; if(getColor(w) == RED)&#123; setColor(w, BLACK); setColor(x.parent, RED); rightRotate(x.parent); w = x.parent.left; &#125; if(getColor(w.right)==BLACK &amp;&amp; getColor(w.left)== BLACK)&#123; setColor(w, RED); x = x.parent; &#125;else &#123; if(getColor(w.right) == RED &amp;&amp; getColor(w.left) == BLACK)&#123; setColor(w.right, BLACK); setColor(w, RED); leftRotate(w); w = x.parent.left; &#125; setColor(w, x.parent.color); setColor(x.parent, BLACK); setColor(w.left, BLACK); rightRotate(x.parent); x=rootNode; &#125; &#125; &#125; //注意这个不在while循环内 setColor(x, BLACK);&#125; 删除了黑色节点后，含有删除节点的所有祖先节点都违背了性质5，所以为了维护性质5。给代替节点多加一层黑色，以代表删除节点的黑色加在了代替节点上。如果代替节点x为根节点，则直接涂上黑色即可；如果代替节点颜色为红色，则直接涂为黑色，如此则给包含删除节点的路径补充了一个黑节点，而且也不会引起性质4的改变。所以循环条件为x != rootNode &amp;&amp; getColor(x) != RED。而且为了恢复性质，可以采取的方法就是将黑色不断上移，直到: x指向红黑节点，即getColor(x)==RED x值向根节点，即x==rootNode 最终步骤就是给红黑节点或者根节点x涂上黑色。 和insert的分析方法一致，先讨论目的情况即在什么情况下能通过旋转着色来恢复红黑性质。 最终目的是将多出来的黑色消除掉，即给x节点所在增加一个节点，再涂为黑色。设x=x.parent.left,为了这个目的，很明显需要在x.parent处左旋以增加节点。为了旋转后保持性质5，需要对sib=x.parent.right,sib.left,sib.right有颜色要求。 旋转后x.parent被涂为黑色，并且增加了一个sib.left为子节点。如果sib为红色，那么sib.left子树的黑高为2，旋转后的x.parent的黑高为3，不符要求，所以sib节点的颜色必须为黑色以占据一个黑高。 sib节点为黑色后，左旋后原右支的sib节点被旋转出，所以右支的黑高减1。为了保持性质5，则给sib.right涂为黑色以加1黑高，所以sib.right的颜色必须为红色。 总1、2，目的情况就是sib节点的颜色必须为黑色，sib.right的颜色必须为红色。其他情况通过旋转着色转换成这种情况即可完成红黑性质的恢复。具体情况和情况间的转换这里不做分析，详情可查看算法导论的解析。 六、红黑树的判断判断一个二叉搜索树是否是红黑树，只需判断是否符合红黑树的5个性质。这里判断的是2,4,5。 要进行判断，首先先定义黑高，采用的是树高的表示和求法，不同的是仅当当前节点为黑色时，高低才加一。而且null节点返回一：12345678910public int getBH(RBTNode x)&#123; if(x == null) return 1; int i=0; if(x.color == BLACK) i=1; int leftBH = i + getBH(x.left); int rightBH = i + getBH(x.right); return leftBH &gt; rightBH ? leftBH : rightBH; &#125; 通过getBH函数来判断节点是否符合性质5：123456789101112private boolean checkBH(RBTNode x)&#123; if(x==null) return true; if(getColor(x) == RED)&#123; if(!(getColor(x.left) == BLACK &amp;&amp; getColor(x.right) == BLACK))&#123; return false; &#125; else &#123; return getBH(x.left) == getBH(x.right) &amp;&amp; checkBH(x.right) &amp;&amp; checkBH(x.left); &#125; &#125; return getBH(x.left) == getBH(x.right)&amp;&amp; checkBH(x.right) &amp;&amp; checkBH(x.left); &#125; 最后直接判断根节点是否为黑色：123public boolean checkRBTree()&#123; return getColor(rootNode) == BLACK &amp;&amp; checkBH(rootNode) ; &#125; 七、总结 在恢复红黑性质过程中，关键思想就是从子树的根到每棵子树之间的黑色节点数不会因变换改变。(旋转着色的要求) 在写fixAfterDeleti和fixAfterinsert时，应该分为以下几个步骤： 找到修正结束的标识，即循环条件 找到目的情况，分析如何通过旋转着色恢复红黑性质 列出其他情况，分析如何转换成目的情况","tags":[{"name":"算法","slug":"算法","permalink":"https://xl2013.github.io/tags/算法/"}]}]